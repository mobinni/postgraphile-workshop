"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveResourceRefPath = exports.parseDatabaseIdentifierFromSmartTag = exports.parseSmartTagsOptsString = exports.addBehaviorToTags = exports.tagToString = void 0;
function tagToString(str) {
    if (!str || (Array.isArray(str) && str.length === 0)) {
        return undefined;
    }
    return Array.isArray(str) ? str.join("\n") : str === true ? " " : str;
}
exports.tagToString = tagToString;
function addBehaviorToTags(tags, behavior, prepend = false) {
    if (Array.isArray(tags.behavior)) {
        if (prepend) {
            tags.behavior = [behavior, ...tags.behavior];
        }
        else {
            tags.behavior = [...tags.behavior, behavior];
        }
    }
    else if (typeof tags.behavior === "string") {
        tags.behavior = prepend
            ? [behavior, tags.behavior]
            : [tags.behavior, behavior];
    }
    else if (!tags.behavior) {
        tags.behavior = [behavior];
    }
    else {
        throw new Error(`Did not understand tags.behavior - it wasn't an array or a string`);
    }
}
exports.addBehaviorToTags = addBehaviorToTags;
var MODE;
(function (MODE) {
    MODE[MODE["EXPECT_ARG"] = 0] = "EXPECT_ARG";
    MODE[MODE["ARG"] = 1] = "ARG";
    MODE[MODE["EXPECT_PARAM_NAME"] = 2] = "EXPECT_PARAM_NAME";
    MODE[MODE["PARAM_NAME"] = 3] = "PARAM_NAME";
    MODE[MODE["EXPECT_PARAM_VALUE"] = 4] = "EXPECT_PARAM_VALUE";
    MODE[MODE["PARAM_VALUE"] = 5] = "PARAM_VALUE";
})(MODE || (MODE = {}));
const IGNORED = /\s/;
const SPECIAL = /[\\":]/;
const SAFE_PARAMETER_NAME = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
function parseSmartTagsOptsString(optsString, leading = 0) {
    const result = {
        args: [],
        params: Object.create(null),
    };
    if (typeof optsString !== "string") {
        return result;
    }
    let leadingLeft = leading;
    let mode = leadingLeft > 0 ? MODE.EXPECT_ARG : MODE.EXPECT_PARAM_NAME;
    let inQuotes = false;
    let str = "";
    let name = "";
    function validateParameterName(name) {
        if (name in result.params) {
            throw new Error(`Parameter '${name}' already set`);
        }
        if (name === "") {
            throw new Error(`Empty parameter name not allowed`);
        }
        if (!SAFE_PARAMETER_NAME.test(name)) {
            throw new Error(`Invalid parameter name`);
        }
        return name;
    }
    function doneOne() {
        switch (mode) {
            case MODE.ARG: {
                result.args.push(str);
                str = "";
                mode = --leadingLeft > 0 ? MODE.EXPECT_ARG : MODE.EXPECT_PARAM_NAME;
                break;
            }
            case MODE.PARAM_NAME: {
                result.params[validateParameterName(str)] = "";
                mode = MODE.EXPECT_PARAM_NAME;
                break;
            }
            case MODE.PARAM_VALUE: {
                result.params[validateParameterName(name)] = str;
                mode = MODE.EXPECT_PARAM_NAME;
                break;
            }
            case MODE.EXPECT_PARAM_VALUE: {
                throw new Error("Unterminated expression string");
            }
            case MODE.EXPECT_ARG: {
                throw new Error("Too few args");
            }
            case MODE.EXPECT_PARAM_NAME: {
                // Fine
                break;
            }
            default: {
                const never = mode;
                throw new Error(`Invalid mode '${never}'`);
            }
        }
    }
    for (let i = 0, l = optsString.length; i < l; i++) {
        const char = optsString[i];
        if (inQuotes) {
            if (char === '"') {
                inQuotes = false;
            }
            else if (char === "\\") {
                const nextChar = optsString[++i];
                if (nextChar !== "\\" && nextChar !== '"') {
                    throw new Error("That escape sequence isn't currently supported");
                }
                str += nextChar;
            }
            else {
                str += char;
            }
        }
        else {
            switch (mode) {
                case MODE.EXPECT_ARG: {
                    if (IGNORED.test(char)) {
                        /* noop */
                    }
                    else {
                        mode = MODE.ARG;
                        if (char === '"') {
                            str = "";
                            inQuotes = true;
                        }
                        else {
                            if (SPECIAL.test(char)) {
                                throw new Error("Invalid position for special char");
                            }
                            str = char;
                        }
                    }
                    break;
                }
                case MODE.EXPECT_PARAM_NAME: {
                    if (IGNORED.test(char)) {
                        /* noop */
                    }
                    else {
                        mode = MODE.PARAM_NAME;
                        if (SPECIAL.test(char)) {
                            throw new Error("Invalid position for special char");
                        }
                        str = char;
                    }
                    break;
                }
                case MODE.EXPECT_PARAM_VALUE: {
                    if (IGNORED.test(char)) {
                        /* noop */
                    }
                    else {
                        mode = MODE.PARAM_VALUE;
                        if (char === '"') {
                            str = "";
                            inQuotes = true;
                        }
                        else {
                            if (SPECIAL.test(char)) {
                                throw new Error("Invalid position for special char");
                            }
                            str = char;
                        }
                    }
                    break;
                }
                case MODE.ARG:
                case MODE.PARAM_NAME:
                case MODE.PARAM_VALUE: {
                    if (IGNORED.test(char)) {
                        doneOne();
                    }
                    else if (char === '"') {
                        inQuotes = true;
                    }
                    else if (char === ":") {
                        if (mode !== MODE.PARAM_NAME) {
                            throw new Error(`The colon character (":") may not occur here; please put it in quote marks. (Processing ${JSON.stringify(optsString)} with ${leading} leading params)`);
                        }
                        else {
                            name = str;
                            str = "";
                            mode = MODE.EXPECT_PARAM_VALUE;
                        }
                    }
                    else if (SPECIAL.test(char)) {
                        throw new Error("Invalid position for special char");
                    }
                    else {
                        str += char;
                    }
                    break;
                }
                default: {
                    const never = mode;
                    throw new Error(`Unhandled mode '${never}'`);
                }
            }
        }
    }
    doneOne();
    return result;
}
exports.parseSmartTagsOptsString = parseSmartTagsOptsString;
function parseDatabaseIdentifierFromSmartTag(identifier, expectedLength, fallbackNamespace = "public") {
    const parts = identifier.split(".");
    // TODO: parse this better!
    if (parts.length > expectedLength || parts.length < expectedLength - 1) {
        throw new Error("Cannot parse database identifier - it has the wrong number of parts");
    }
    const bits = parts.map((part) => {
        if (part[0] === '"') {
            if (part[part.length - 1] !== '"') {
                throw new Error(`Cannot parse database identifier; invalid quoting '${part}'`);
            }
            return part.slice(1, part.length - 1);
        }
        else {
            return part;
        }
    });
    if (bits.length < expectedLength) {
        return [fallbackNamespace, ...bits];
    }
    else {
        return bits;
    }
}
exports.parseDatabaseIdentifierFromSmartTag = parseDatabaseIdentifierFromSmartTag;
const resolveResourceRefPath = (resource, path) => {
    if (!resource) {
        throw new Error(`Cannot call resolvePath unless there's a resource`);
    }
    const result = {
        resource,
        hasReferencee: false,
        isUnique: true,
        layers: [],
    };
    for (const pathEntry of path) {
        const relation = result.resource.getRelation(pathEntry.relationName);
        const { isReferencee, localAttributes, remoteAttributes, remoteResource: resource, isUnique, } = relation;
        if (isReferencee) {
            result.hasReferencee = true;
        }
        if (!isUnique) {
            result.isUnique = false;
        }
        result.layers.push({
            relationName: pathEntry.relationName,
            localAttributes: localAttributes,
            remoteAttributes: remoteAttributes,
            resource,
            isUnique,
        });
        result.resource = relation.remoteResource;
    }
    return result;
};
exports.resolveResourceRefPath = resolveResourceRefPath;
//# sourceMappingURL=utils.js.map