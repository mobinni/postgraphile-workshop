"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyOrderToPlan = exports.PgConnectionArgOrderByPlugin = void 0;
require("./PgTablesPlugin.js");
require("graphile-config");
const grafast_1 = require("grafast");
const graphile_build_1 = require("graphile-build");
const util_1 = require("util");
const version_js_1 = require("../version.js");
exports.PgConnectionArgOrderByPlugin = {
    name: "PgConnectionArgOrderByPlugin",
    description: "Adds the 'orderBy' argument to connections and simple collections",
    version: version_js_1.version,
    inflection: {
        add: {
            orderByType(options, typeName) {
                return this.upperCamelCase(`${typeName}-order-by`);
            },
        },
    },
    schema: {
        entityBehavior: {
            pgCodec: "order",
            pgResource: {
                provides: ["default"],
                before: ["inferred", "override"],
                callback(behavior, resource) {
                    if (resource.parameters) {
                        return behavior;
                    }
                    else {
                        return ["order", behavior];
                    }
                },
            },
        },
        hooks: {
            init(_, build) {
                const { inflection, pgCodecMetaLookup } = build;
                pgCodecMetaLookup.forEach((meta, codec) => {
                    if (!codec.attributes || codec.isAnonymous)
                        return;
                    // TODO: should this be `type:order` or similar?
                    if (!build.behavior.pgCodecMatches(codec, "order")) {
                        return;
                    }
                    const tableTypeName = inflection.tableType(codec);
                    /* const TableOrderByType = */
                    const typeName = inflection.orderByType(tableTypeName);
                    build.registerEnumType(typeName, {
                        pgCodec: codec,
                        isPgRowSortEnum: true,
                    }, () => ({
                        description: build.wrapDescription(`Methods to use when ordering \`${tableTypeName}\`.`, "type"),
                        values: {
                            [inflection.builtin("NATURAL")]: {
                                extensions: {
                                    grafast: {
                                        // NATURAL means to not change the sort order
                                        applyPlan: (0, graphile_build_1.EXPORTABLE)(() => () => { }, []),
                                    },
                                },
                            },
                        },
                    }), `Adding connection "orderBy" argument for ${codec.name}.`);
                    if (codec.polymorphism?.mode === "single") {
                        // TODO: register OrderBy for each concrete type
                    }
                });
                return _;
            },
            GraphQLObjectType_fields_field_args(args, build, context) {
                const { extend, getTypeByName, graphql: { GraphQLList, GraphQLNonNull }, inflection, } = build;
                const { scope, Self } = context;
                const { fieldName, isPgFieldConnection, isPgFieldSimpleCollection, pgFieldResource: pgResource, pgFieldCodec, } = scope;
                if (!isPgFieldConnection && !isPgFieldSimpleCollection) {
                    return args;
                }
                const codec = pgFieldCodec ?? pgResource?.codec;
                const isSuitableSource = pgResource && pgResource.codec.attributes && !pgResource.isUnique;
                const isSuitableCodec = codec &&
                    (isSuitableSource ||
                        (!pgResource && codec?.polymorphism?.mode === "union")) &&
                    codec.attributes;
                if (!isSuitableCodec) {
                    return args;
                }
                if (pgResource
                    ? !build.behavior.pgResourceMatches(pgResource, "order")
                    : codec
                        ? !build.behavior.pgCodecMatches(codec, "order")
                        : false) {
                    return args;
                }
                const tableTypeName = inflection.tableType(codec);
                const tableOrderByTypeName = inflection.orderByType(tableTypeName);
                const TableOrderByType = getTypeByName(tableOrderByTypeName);
                if (!TableOrderByType) {
                    return args;
                }
                return extend(args, {
                    orderBy: {
                        description: build.wrapDescription(`The method to use when ordering \`${tableTypeName}\`.`, "arg"),
                        type: new GraphQLList(new GraphQLNonNull(TableOrderByType)),
                        autoApplyAfterParentPlan: true,
                        applyPlan: isPgFieldConnection
                            ? (0, graphile_build_1.EXPORTABLE)((applyOrderToPlan, tableOrderByTypeName) => function plan(_, $connection, val, info) {
                                const $value = val.getRaw();
                                const $select = $connection.getSubplan();
                                applyOrderToPlan($select, $value, info.schema.getType(tableOrderByTypeName));
                                return null;
                            }, [exports.applyOrderToPlan, tableOrderByTypeName])
                            : (0, graphile_build_1.EXPORTABLE)((applyOrderToPlan, tableOrderByTypeName) => function plan(_, $select, val, info) {
                                const $value = val.getRaw();
                                applyOrderToPlan($select, $value, info.schema.getType(tableOrderByTypeName));
                                return null;
                            }, [exports.applyOrderToPlan, tableOrderByTypeName]),
                    },
                }, `Adding 'orderBy' argument to field '${fieldName}' of '${Self.name}'`);
            },
        },
    },
};
exports.applyOrderToPlan = (0, graphile_build_1.EXPORTABLE)((SafeError, getEnumValueConfig, inspect) => ($select, $value, TableOrderByType) => {
    const val = $value.eval();
    if (!Array.isArray(val)) {
        throw new Error("Invalid!");
    }
    val.forEach((order) => {
        const config = getEnumValueConfig(TableOrderByType, order);
        const plan = config?.extensions?.grafast?.applyPlan;
        if (typeof plan !== "function") {
            console.error(`Internal server error: invalid orderBy configuration: expected function, but received ${inspect(plan)}`);
            throw new SafeError("Internal server error: invalid orderBy configuration");
        }
        plan($select);
    });
}, [grafast_1.SafeError, grafast_1.getEnumValueConfig, util_1.inspect]);
//# sourceMappingURL=PgConnectionArgOrderByPlugin.js.map