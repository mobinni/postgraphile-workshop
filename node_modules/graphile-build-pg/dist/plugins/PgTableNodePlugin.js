"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgTableNodePlugin = void 0;
const tslib_1 = require("tslib");
require("graphile-config");
const grafast_1 = require("grafast");
const graphile_build_1 = require("graphile-build");
const tamedevil_1 = tslib_1.__importStar(require("tamedevil"));
const utils_js_1 = require("../utils.js");
const version_js_1 = require("../version.js");
function canSupportNode(resource) {
    return (!resource.codec.isAnonymous &&
        !!resource.codec.attributes &&
        !resource.codec.polymorphism &&
        !resource.parameters &&
        !!resource.uniques &&
        !!resource.uniques[0]);
}
exports.PgTableNodePlugin = {
    name: "PgTableNodePlugin",
    description: "Add the 'Node' interface to table types",
    version: version_js_1.version,
    schema: {
        entityBehavior: {
            pgResource: {
                provides: ["default"],
                before: ["inferred", "override"],
                callback(behavior, resource) {
                    if (canSupportNode(resource)) {
                        return ["node", "select", behavior];
                    }
                    else {
                        return behavior;
                    }
                },
            },
        },
        hooks: {
            init(_, build) {
                if (!build.registerNodeIdHandler) {
                    return _;
                }
                const tableResources = Object.values(build.input.pgRegistry.pgResources).filter((resource) => {
                    if (!canSupportNode(resource))
                        return false;
                    // Needs the 'select' and 'node' behaviours for compatibility
                    return (!!build.behavior.pgResourceMatches(resource, "node") &&
                        !!build.behavior.pgResourceMatches(resource, "select"));
                });
                const resourcesByCodec = new Map();
                for (const resource of tableResources) {
                    let list = resourcesByCodec.get(resource.codec);
                    if (!list) {
                        list = [];
                        resourcesByCodec.set(resource.codec, list);
                    }
                    list.push(resource);
                }
                for (const [codec, resources] of resourcesByCodec.entries()) {
                    const tableTypeName = build.inflection.tableType(codec);
                    if (resources.length !== 1) {
                        console.warn(`Found multiple table resources for codec '${codec.name}'; we don't currently support that but we _could_ - get in touch if you need this.`);
                        continue;
                    }
                    const pgResource = resources[0];
                    const primaryKey = pgResource.uniques.find((u) => u.isPrimary === true);
                    if (!primaryKey) {
                        continue;
                    }
                    const pk = primaryKey.attributes;
                    const identifier = 
                    // Yes, this behaviour in V4 was ridiculous. Alas.
                    build.options.pgV4UseTableNameForNodeIdentifier &&
                        pgResource.extensions?.pg?.name
                        ? build.inflection.pluralize(pgResource.extensions.pg.name)
                        : tableTypeName;
                    const clean = (0, tamedevil_1.isSafeObjectPropertyName)(identifier) &&
                        pk.every((attributeName) => (0, tamedevil_1.isSafeObjectPropertyName)(attributeName));
                    const firstSource = resources.find((s) => !s.parameters);
                    build.registerNodeIdHandler({
                        typeName: tableTypeName,
                        codecName: "base64JSON",
                        deprecationReason: (0, utils_js_1.tagToString)(codec.extensions?.tags?.deprecation ??
                            firstSource?.extensions?.tags?.deprecated),
                        plan: clean
                            ? // eslint-disable-next-line graphile-export/exhaustive-deps
                                (0, graphile_build_1.EXPORTABLE)(tamedevil_1.default.run `\
return function (list, constant) {
  return $record => list([constant(${tamedevil_1.default.lit(identifier)}), ${tamedevil_1.default.join(pk.map((attributeName) => (0, tamedevil_1.default) `$record.get(${tamedevil_1.default.lit(attributeName)})`), ", ")}]);
}`, [grafast_1.list, grafast_1.constant])
                            : (0, graphile_build_1.EXPORTABLE)((constant, identifier, list, pk) => ($record) => {
                                return list([
                                    constant(identifier),
                                    ...pk.map((attribute) => $record.get(attribute)),
                                ]);
                            }, [grafast_1.constant, identifier, grafast_1.list, pk]),
                        getSpec: clean
                            ? // eslint-disable-next-line graphile-export/exhaustive-deps
                                (0, graphile_build_1.EXPORTABLE)(tamedevil_1.default.run `\
return function (access) {
  return $list => ({ ${tamedevil_1.default.join(pk.map((attributeName, index) => (0, tamedevil_1.default) `${tamedevil_1.default.dangerousKey(attributeName)}: access($list, [${tamedevil_1.default.lit(index + 1)}])`), ", ")} });
}`, [grafast_1.access])
                            : (0, graphile_build_1.EXPORTABLE)((access, pk) => ($list) => {
                                const spec = pk.reduce((memo, attribute, index) => {
                                    memo[attribute] = access($list, [index + 1]);
                                    return memo;
                                }, Object.create(null));
                                return spec;
                            }, [grafast_1.access, pk]),
                        get: (0, graphile_build_1.EXPORTABLE)((pgResource) => (spec) => pgResource.get(spec), [pgResource]),
                        match: (0, graphile_build_1.EXPORTABLE)((identifier) => (obj) => {
                            return obj[0] === identifier;
                        }, [identifier]),
                    });
                }
                return _;
            },
        },
    },
};
//# sourceMappingURL=PgTableNodePlugin.js.map