"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgJWTPlugin = void 0;
require("graphile-config");
const graphile_build_1 = require("graphile-build");
const jsonwebtoken_1 = require("jsonwebtoken");
const version_js_1 = require("../version.js");
exports.PgJWTPlugin = {
    name: "PgJWTPlugin",
    description: "Converts a Postgres JWT object type into a GraphQL scalar type containing a signed JWT",
    version: version_js_1.version,
    before: ["PgCodecsPlugin", "PgTablesPlugin"],
    gather: {
        namespace: "pgJWT",
        helpers: {},
        hooks: {
            pgCodecs_PgCodec(info, { pgCodec, pgType }) {
                if (info.options.pgJwtType?.[1] === pgType.typname &&
                    info.options.pgJwtType?.[0] === pgType.getNamespace().nspname) {
                    // It's a JWT type!
                    pgCodec.extensions ||= Object.create(null);
                    pgCodec.extensions.tags ||= Object.create(null);
                    pgCodec.extensions.tags.behavior = ["-table", "jwt"];
                }
            },
        },
    },
    schema: {
        hooks: {
            init(_, build) {
                const { options: { pgJwtSecret, pgJwtSignOptions }, } = build;
                const jwtCodec = [...build.pgCodecMetaLookup.keys()].find((codec) => 
                // TODO: why is b.jwt_token not found here?
                build.behavior.pgCodecMatches(codec, "jwt"));
                if (!jwtCodec) {
                    return _;
                }
                if (!jwtCodec.attributes) {
                    throw new Error(`JWT codec '${jwtCodec.name}' found, but it does not appear to have any attributes. Please check your configuration, the JWT type should be a composite type.`);
                }
                const jwtTypeName = build.inflection.tableType(jwtCodec);
                const attributeNames = Object.keys(jwtCodec.attributes);
                build.registerScalarType(jwtTypeName, {
                    isPgJwtType: true,
                    pgCodec: jwtCodec,
                }, () => ({
                    description: build.wrapDescription("A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519) which securely represents claims between two parties.", "type"),
                    serialize: (0, graphile_build_1.EXPORTABLE)((attributeNames, pgJwtSecret, pgJwtSignOptions, signJwt) => function serialize(value) {
                        const token = attributeNames.reduce((memo, attributeName) => {
                            if (attributeName === "exp") {
                                memo[attributeName] = value[attributeName]
                                    ? parseFloat(value[attributeName])
                                    : undefined;
                            }
                            else {
                                memo[attributeName] = value[attributeName];
                            }
                            return memo;
                        }, {});
                        const options = Object.assign(Object.create(null), pgJwtSignOptions, token.aud || (pgJwtSignOptions && pgJwtSignOptions.audience)
                            ? null
                            : {
                                audience: "postgraphile",
                            }, token.iss || (pgJwtSignOptions && pgJwtSignOptions.issuer)
                            ? null
                            : {
                                issuer: "postgraphile",
                            }, token.exp ||
                            (pgJwtSignOptions && pgJwtSignOptions.expiresIn)
                            ? null
                            : {
                                expiresIn: "1 day",
                            });
                        return signJwt(token, pgJwtSecret, options);
                    }, [attributeNames, pgJwtSecret, pgJwtSignOptions, jsonwebtoken_1.sign]),
                    extensions: {
                        grafast: {
                            plan: (0, graphile_build_1.EXPORTABLE)(() => function plan($in) {
                                const $record = $in;
                                return $record.record();
                            }, []),
                        },
                    },
                }), "JWT scalar from PgJWTPlugin");
                build.setGraphQLTypeForPgCodec(jwtCodec, "output", jwtTypeName);
                return _;
            },
        },
    },
};
//# sourceMappingURL=PgJWTPlugin.js.map