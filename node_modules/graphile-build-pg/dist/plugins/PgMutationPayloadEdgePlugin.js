"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgMutationPayloadEdgePlugin = void 0;
require("graphile-config");
const pg_1 = require("@dataplan/pg");
const grafast_1 = require("grafast");
const graphile_build_1 = require("graphile-build");
const utils_js_1 = require("../utils.js");
const version_js_1 = require("../version.js");
const PgConnectionArgOrderByPlugin_js_1 = require("./PgConnectionArgOrderByPlugin.js");
exports.PgMutationPayloadEdgePlugin = {
    name: "PgMutationPayloadEdgePlugin",
    description: "Adds 'edge' field to mutation payloads to aid with Relay pagination",
    version: version_js_1.version,
    inflection: {
        add: {
            tableEdgeField(options, codec) {
                return this.camelCase(this.tableEdgeType(codec));
            },
        },
    },
    schema: {
        hooks: {
            GraphQLObjectType_fields(fields, build, context) {
                const { extend, getTypeByName, graphql: { GraphQLList, GraphQLNonNull }, inflection, } = build;
                const { scope: { isMutationPayload, pgTypeResource, pgCodec: _pgCodec }, fieldWithHooks, Self, } = context;
                const pgCodec = pgTypeResource?.codec ?? _pgCodec;
                if (!isMutationPayload ||
                    !pgCodec ||
                    !pgCodec.attributes ||
                    pgCodec.isAnonymous) {
                    return fields;
                }
                if (pgTypeResource?.parameters && !pgTypeResource.isUnique) {
                    return fields;
                }
                // TODO: this is a rule on the codec; we must ensure that everywhere
                // that uses 'list'/'connection' respects the codec behaviors
                if (!build.behavior.pgCodecMatches(pgCodec, "*:connection")) {
                    return fields;
                }
                const resources = Object.values(build.input.pgRegistry.pgResources).filter((resource) => {
                    if (resource.codec !== pgCodec)
                        return false;
                    if (resource.parameters)
                        return false;
                    return true;
                });
                if (resources.length !== 1) {
                    return fields;
                }
                const resource = resources[0];
                const pk = resource.uniques?.find((u) => u.isPrimary);
                if (!pk) {
                    return fields;
                }
                const pkAttributes = pk.attributes;
                const TableType = build.getGraphQLTypeByPgCodec(pgCodec, "output");
                if (!TableType) {
                    return fields;
                }
                const tableTypeName = TableType.name;
                const tableOrderByTypeName = inflection.orderByType(tableTypeName);
                const TableOrderByType = getTypeByName(tableOrderByTypeName);
                if (!TableOrderByType) {
                    return fields;
                }
                const TableEdgeType = getTypeByName(inflection.tableEdgeType(resource.codec));
                if (!TableEdgeType) {
                    return fields;
                }
                const fieldName = inflection.tableEdgeField(resource.codec);
                const primaryKeyAsc = inflection.builtin("PRIMARY_KEY_ASC");
                const defaultValueEnum = TableOrderByType.getValues().find((v) => v.name === primaryKeyAsc) ||
                    TableOrderByType.getValues()[0];
                return extend(fields, {
                    [fieldName]: fieldWithHooks({
                        fieldName,
                        // TODO: fieldBehaviorScope: `...`,
                        isPgMutationPayloadEdgeField: true,
                        pgCodec: pgCodec,
                    }, () => ({
                        description: build.wrapDescription(`An edge for our \`${tableTypeName}\`. May be used by Relay 1.`, "field"),
                        type: TableEdgeType,
                        args: {
                            orderBy: {
                                description: build.wrapDescription(`The method to use when ordering \`${tableTypeName}\`.`, "arg"),
                                type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(TableOrderByType))),
                                defaultValue: defaultValueEnum
                                    ? [defaultValueEnum.value]
                                    : null,
                            },
                        },
                        deprecationReason: (0, utils_js_1.tagToString)(resource.extensions?.tags?.deprecated),
                        // TODO: review this plan, it feels overly complex and somewhat hacky.
                        plan: (0, graphile_build_1.EXPORTABLE)((EdgeStep, PgDeleteSingleStep, applyOrderToPlan, connection, constant, pgSelectFromRecord, pkAttributes, resource, tableOrderByTypeName) => function plan($mutation, args, info) {
                            const $result = $mutation.getStepForKey("result", true);
                            if (!$result) {
                                return constant(null);
                            }
                            const $select = (() => {
                                if ($result instanceof PgDeleteSingleStep) {
                                    return pgSelectFromRecord($result.resource, $result.record());
                                }
                                else {
                                    const spec = pkAttributes.reduce((memo, attributeName) => {
                                        memo[attributeName] = $result.get(attributeName);
                                        return memo;
                                    }, Object.create(null));
                                    return resource.find(spec);
                                }
                            })();
                            // Perform ordering
                            const $value = args.getRaw("orderBy");
                            applyOrderToPlan($select, $value, info.schema.getType(tableOrderByTypeName));
                            const $connection = connection($select);
                            const $single = $select.single();
                            return new EdgeStep($connection, $single);
                        }, [
                            grafast_1.EdgeStep,
                            pg_1.PgDeleteSingleStep,
                            PgConnectionArgOrderByPlugin_js_1.applyOrderToPlan,
                            grafast_1.connection,
                            grafast_1.constant,
                            pg_1.pgSelectFromRecord,
                            pkAttributes,
                            resource,
                            tableOrderByTypeName,
                        ]),
                    })),
                }, `Adding edge field for table ${pgCodec.name} to mutation payload '${Self.name}'`);
            },
        },
    },
};
//# sourceMappingURL=PgMutationPayloadEdgePlugin.js.map