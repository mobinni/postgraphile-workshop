"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgInterfaceModeUnionAllRowsPlugin = void 0;
require("graphile-config");
const pg_1 = require("@dataplan/pg");
const grafast_1 = require("grafast");
const graphile_build_1 = require("graphile-build");
const version_js_1 = require("../version.js");
exports.PgInterfaceModeUnionAllRowsPlugin = {
    name: "PgInterfaceModeUnionAllRowsPlugin",
    version: version_js_1.version,
    inflection: {
        add: {
            allInterfaceModeUnionRowsConnection(options, codec) {
                return this.connectionField(this.camelCase(`all-${this.pluralize(this._singularizedCodecName(codec))}`));
            },
            allInterfaceModeUnionRowsList(options, codec) {
                return this.listField(this.camelCase(`all-${this.pluralize(this._singularizedCodecName(codec))}`));
            },
        },
    },
    schema: {
        entityBehavior: {
            pgCodec: {
                provides: ["default"],
                before: ["inferred", "override"],
                callback(behavior, entity) {
                    if (entity.polymorphism?.mode === "union") {
                        return ["connection -list", behavior];
                    }
                    else {
                        return behavior;
                    }
                },
            },
        },
        hooks: {
            GraphQLObjectType_fields(fields, build, context) {
                const { inflection, input, graphql: { GraphQLList, GraphQLNonNull }, } = build;
                const { scope: { isRootQuery }, fieldWithHooks, } = context;
                if (!isRootQuery) {
                    return fields;
                }
                const pgRegistry = input.pgRegistry;
                const resourcesByPolymorphicTypeName = Object.create(null);
                const allResources = Object.values(pgRegistry.pgResources);
                for (const resource of allResources) {
                    if (resource.parameters)
                        continue;
                    if (typeof resource.from === "function")
                        continue;
                    if (!resource.codec.extensions?.tags)
                        continue;
                    const { implements: implementsTag } = resource.codec.extensions.tags;
                    /*
                    const { unionMember } = resource.codec.extensions.tags;
                    if (unionMember) {
                      const unions = Array.isArray(unionMember)
                        ? unionMember
                        : [unionMember];
                      for (const union of unions) {
                        if (!resourcesByPolymorphicTypeName[union]) {
                          resourcesByPolymorphicTypeName[union] = {
                            resources: [resource as PgResource],
                            type: "union",
                          };
                        } else {
                          if (resourcesByPolymorphicTypeName[union].type !== "union") {
                            throw new Error(`Inconsistent polymorphism`);
                          }
                          resourcesByPolymorphicTypeName[union].resources.push(
                            resource as PgResource,
                          );
                        }
                      }
                    }
                    */
                    if (implementsTag) {
                        const interfaces = Array.isArray(implementsTag)
                            ? implementsTag
                            : [implementsTag];
                        for (const interfaceName of interfaces) {
                            if (!resourcesByPolymorphicTypeName[interfaceName]) {
                                resourcesByPolymorphicTypeName[interfaceName] = {
                                    resources: [resource],
                                    type: "interface",
                                };
                            }
                            else {
                                if (resourcesByPolymorphicTypeName[interfaceName].type !==
                                    "interface") {
                                    throw new Error(`Inconsistent polymorphism`);
                                }
                                resourcesByPolymorphicTypeName[interfaceName].resources.push(resource);
                            }
                        }
                    }
                }
                const interfaceCodecs = Object.create(null);
                for (const codec of Object.values(pgRegistry.pgCodecs)) {
                    if (!codec.polymorphism)
                        continue;
                    if (codec.polymorphism.mode !== "union")
                        continue;
                    const interfaceTypeName = inflection.tableType(codec);
                    interfaceCodecs[interfaceTypeName] = codec;
                    // Explicitly allow zero implementations.
                    if (!resourcesByPolymorphicTypeName[interfaceTypeName]) {
                        resourcesByPolymorphicTypeName[interfaceTypeName] = {
                            resources: [],
                            type: "interface",
                        };
                    }
                }
                for (const [polymorphicTypeName, spec] of Object.entries(resourcesByPolymorphicTypeName)) {
                    if (spec.type === "union") {
                        // We can't add a root field for a basic union because there's
                        // nothing to order it by - we wouldn't be able to reliably
                        // paginate.
                    }
                    else if (spec.type === "interface") {
                        const interfaceCodec = interfaceCodecs[polymorphicTypeName];
                        if (!interfaceCodec) {
                            console.warn(`A number of resources claim to implement '${polymorphicTypeName}', but we couldn't find the definition for that type so we won't add a root field for it. (Perhaps you implemented it in makeExtendSchemaPlugin?) Affected resources: ${spec.resources
                                .map((r) => r.name)
                                .join(", ")}`);
                            continue;
                        }
                        if (interfaceCodec.polymorphism?.mode !== "union") {
                            // 'single' and 'relational' are already handled by PgAllRowsPlugin
                            continue;
                        }
                        const makeField = (useConnection) => {
                            if (!interfaceCodec.polymorphism)
                                return;
                            const type = build.getTypeByName(build.inflection.tableType(interfaceCodec));
                            if (!type)
                                return;
                            const fieldType = useConnection
                                ? build.getTypeByName(build.inflection.tableConnectionType(interfaceCodec))
                                : // TODO: nullability.
                                    new GraphQLList(new GraphQLNonNull(type));
                            if (!fieldType)
                                return;
                            const fieldName = useConnection
                                ? inflection.allInterfaceModeUnionRowsConnection(interfaceCodec)
                                : inflection.allInterfaceModeUnionRowsList(interfaceCodec);
                            if (!interfaceCodec.attributes)
                                return;
                            const attributes = interfaceCodec.attributes;
                            const resourceByTypeName = Object.create(null);
                            const members = [];
                            for (const resource of spec.resources) {
                                const typeName = inflection.tableType(resource.codec);
                                resourceByTypeName[typeName] = resource;
                                members.push({
                                    resource,
                                    typeName,
                                });
                            }
                            build.extend(fields, {
                                [fieldName]: fieldWithHooks({
                                    fieldName,
                                    isPgFieldConnection: useConnection,
                                    isPgFieldSimpleCollection: !useConnection,
                                    pgFieldCodec: interfaceCodec,
                                }, {
                                    type: fieldType,
                                    plan: (0, graphile_build_1.EXPORTABLE)((attributes, connection, members, pgUnionAll, resourceByTypeName, useConnection) => {
                                        return function plan() {
                                            const $list = pgUnionAll({
                                                attributes,
                                                resourceByTypeName,
                                                members,
                                            });
                                            return useConnection ? connection($list) : $list;
                                        };
                                    }, [
                                        attributes,
                                        grafast_1.connection,
                                        members,
                                        pg_1.pgUnionAll,
                                        resourceByTypeName,
                                        useConnection,
                                    ]),
                                }),
                            }, `Adding polymorphic "all rows" ${useConnection ? "connection" : "list"} field for ${interfaceCodec.name} to the root query`);
                        };
                        if (build.behavior.pgCodecMatches(interfaceCodec, "query:interface:connection")) {
                            makeField(true);
                        }
                        if (build.behavior.pgCodecMatches(interfaceCodec, "query:interface:list")) {
                            makeField(false);
                        }
                    }
                    else {
                        const never = spec.type;
                        console.warn(`GraphileInternalError<f107e83d-087e-4116-8aaf-15da83f76f88>: Internal consistency issue: ${never} unhandled`);
                    }
                }
                return fields;
            },
        },
    },
};
//# sourceMappingURL=PgInterfaceModeUnionAllRowsPlugin.js.map