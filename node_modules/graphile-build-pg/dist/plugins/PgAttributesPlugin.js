"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgAttributesPlugin = void 0;
require("./PgTablesPlugin.js");
require("../interfaces.js");
require("graphile-config");
const pg_1 = require("@dataplan/pg");
const graphile_build_1 = require("graphile-build");
const version_js_1 = require("../version.js");
function unwrapCodec(codec) {
    if (codec.arrayOfCodec) {
        return unwrapCodec(codec.arrayOfCodec);
    }
    return codec;
}
// TODO: get rid of this! Determine the resources at build time
const getResource = (0, graphile_build_1.EXPORTABLE)((PgResource) => (registry, baseCodec, pgResources, $record) => {
    const executor = $record.resource.executor;
    const resource = pgResources.find((potentialSource) => 
    // These have already been filtered by codec
    potentialSource.executor === executor) ??
        // HACK: yuck yuck yuck
        // TODO: yuck; we should not be building a PgResource on demand. We
        // should be able to detect this is necessary and add it to the
        // registry preemptively.
        new PgResource(registry, PgResource.configFromCodec(executor, baseCodec));
    return resource;
}, [pg_1.PgResource]);
function processAttribute(fields, build, context, attributeName, overrideName) {
    const { extend, graphql: { getNullableType, GraphQLNonNull, GraphQLList }, inflection, getGraphQLTypeByPgCodec, input: { pgRegistry: registry }, } = build;
    const { scope: { pgCodec: rawPgCodec }, } = context;
    if (!rawPgCodec || !rawPgCodec.attributes) {
        return;
    }
    const pgCodec = rawPgCodec;
    const isInterface = context.type === "GraphQLInterfaceType";
    const attribute = pgCodec.attributes[attributeName];
    if (!build.behavior.pgCodecAttributeMatches([pgCodec, attribute], "attribute:select")) {
        // Don't allow selecting this attribute.
        return;
    }
    const attributeFieldName = overrideName ??
        inflection.attribute({
            attributeName,
            codec: pgCodec,
        });
    const baseCodec = unwrapCodec(attribute.codec);
    const baseType = getGraphQLTypeByPgCodec(baseCodec, "output");
    const arrayOrNotType = attribute.codec.arrayOfCodec
        ? new GraphQLList(baseType)
        : baseType;
    if (!arrayOrNotType) {
        console.warn(`Couldn't find a 'output' variant for PgCodec ${pgCodec.name}'s '${attributeName}' attribute (${attribute.codec.name}; array=${!!attribute.codec.arrayOfCodec}, domain=${!!attribute.codec
            .domainOfCodec}, enum=${!!attribute.codec.values})`);
        return;
    }
    const type = attribute.notNull
        ? new GraphQLNonNull(getNullableType(arrayOrNotType))
        : arrayOrNotType;
    if (!type) {
        // Could not determine the type, skip this field
        console.warn(`Could not determine the type for attribute '${attributeName}' of ${pgCodec.name}`);
        return;
    }
    const fieldSpec = {
        description: attribute.description,
        type: type,
    };
    if (!isInterface) {
        const makePlan = () => {
            // See if there's a resource to pull record types from (e.g. for relations/etc)
            if (!baseCodec.attributes) {
                // Simply get the value
                return (0, graphile_build_1.EXPORTABLE)((attributeName) => ($record) => {
                    return $record.get(attributeName);
                }, [attributeName]);
            }
            else {
                const pgResources = Object.values(registry.pgResources).filter((potentialSource) => potentialSource.codec === baseCodec && !potentialSource.parameters);
                // TODO: this is pretty horrible in the export; we should fix that.
                if (!attribute.codec.arrayOfCodec) {
                    const notNull = attribute.notNull || attribute.codec.notNull;
                    // Single record from resource
                    /*
                     * TODO: if we refactor `PgSelectSingleStep` we can probably
                     * optimise this to do inline selection and still join against
                     * the base table using e.g. `(table.column).attribute =
                     * joined_thing.column`
                     */
                    return (0, graphile_build_1.EXPORTABLE)((attributeName, baseCodec, getResource, notNull, pgResources, pgSelectSingleFromRecord, registry) => ($record) => {
                        const $plan = $record.get(attributeName);
                        const $select = pgSelectSingleFromRecord(getResource(registry, baseCodec, pgResources, $record), $plan);
                        if (notNull) {
                            $select.coalesceToEmptyObject();
                        }
                        $select.getClassStep().setTrusted();
                        return $select;
                    }, [
                        attributeName,
                        baseCodec,
                        getResource,
                        notNull,
                        pgResources,
                        pg_1.pgSelectSingleFromRecord,
                        registry,
                    ]);
                }
                else {
                    // Many records from resource
                    /*
                     * TODO: if we refactor `PgSelectSingleStep` we can probably
                     * optimise this to do inline selection and still join against
                     * the base table using e.g. `(table.column).attribute =
                     * joined_thing.column`
                     */
                    return (0, graphile_build_1.EXPORTABLE)((attributeName, baseCodec, getResource, pgResources, pgSelectFromRecords, registry) => ($record) => {
                        const $val = $record.get(attributeName);
                        const $select = pgSelectFromRecords(getResource(registry, baseCodec, pgResources, $record), $val);
                        $select.setTrusted();
                        return $select;
                    }, [
                        attributeName,
                        baseCodec,
                        getResource,
                        pgResources,
                        pg_1.pgSelectFromRecords,
                        registry,
                    ]);
                }
            }
        };
        fieldSpec.plan = makePlan();
    }
    fields = extend(fields, {
        [attributeFieldName]: context.fieldWithHooks({
            fieldName: attributeFieldName,
            pgFieldAttribute: attribute,
        }, fieldSpec),
    }, `Adding '${attributeName}' attribute field to PgCodec '${pgCodec.name}'`);
}
exports.PgAttributesPlugin = {
    name: "PgAttributesPlugin",
    description: "Adds PostgreSQL attributes (columns) to the relevant GraphQL object/input object types",
    version: version_js_1.version,
    after: ["PgTablesPlugin"],
    inflection: {
        add: {
            _attributeName(options, { attributeName, codec }) {
                const attribute = codec.attributes[attributeName];
                return this.coerceToGraphQLName(attribute.extensions?.tags?.name || attributeName);
            },
            _joinAttributeNames(options, codec, names) {
                return names
                    .map((attributeName) => {
                    return this.attribute({ attributeName, codec });
                })
                    .join("-and-");
            },
            attribute(options, details) {
                const attributeFieldName = this.camelCase(this._attributeName(details));
                // Avoid conflict with 'id' field used for Relay.
                return attributeFieldName === "id" && !details.codec.isAnonymous
                    ? "rowId"
                    : attributeFieldName;
            },
        },
    },
    schema: {
        entityBehavior: {
            pgCodecAttribute: "select base update insert",
        },
        hooks: {
            GraphQLInterfaceType_fields(fields, build, context) {
                const { scope: { pgCodec, pgPolymorphism }, } = context;
                if (!pgPolymorphism || !pgCodec?.attributes) {
                    return fields;
                }
                for (const attributeName in pgCodec.attributes) {
                    switch (pgPolymorphism.mode) {
                        case "single": {
                            if (!pgPolymorphism.commonAttributes.includes(attributeName)) {
                                continue;
                            }
                            break;
                        }
                        case "relational": {
                            break;
                        }
                        case "union": {
                            break;
                        }
                        default: {
                            const never = pgPolymorphism;
                            throw new Error(`Unhandled polymorphism mode ${never.mode}}`);
                        }
                    }
                    processAttribute(fields, build, context, attributeName);
                }
                return fields;
            },
            GraphQLObjectType_fields(fields, build, context) {
                const { scope: { pgCodec, isPgClassType, pgPolymorphism, pgPolymorphicSingleTableType, }, } = context;
                if (!isPgClassType || !pgCodec?.attributes) {
                    return fields;
                }
                for (const attributeName in pgCodec.attributes) {
                    let overrideName = undefined;
                    if (pgPolymorphism) {
                        switch (pgPolymorphism.mode) {
                            case "single": {
                                const match = pgPolymorphicSingleTableType?.attributes.find((c) => c.attribute === attributeName);
                                if (!pgPolymorphism.commonAttributes.includes(attributeName) &&
                                    !match) {
                                    continue;
                                }
                                if (match?.rename) {
                                    overrideName = match.rename;
                                }
                                break;
                            }
                            case "relational": {
                                break;
                            }
                            case "union": {
                                break;
                            }
                            default: {
                                const never = pgPolymorphism;
                                throw new Error(`Unhandled polymorphism mode ${never.mode}}`);
                            }
                        }
                    }
                    processAttribute(fields, build, context, attributeName, overrideName);
                }
                return fields;
            },
            GraphQLInputObjectType_fields(fields, build, context) {
                const { extend, inflection } = build;
                const { scope: { isPgRowType, isPgCompoundType, isPgPatch, isPgBaseInput, pgCodec: rawPgCodec, }, fieldWithHooks, } = context;
                if (!(isPgRowType || isPgCompoundType) ||
                    !rawPgCodec ||
                    !rawPgCodec.attributes ||
                    rawPgCodec.isAnonymous) {
                    return fields;
                }
                const pgCodec = rawPgCodec;
                return Object.entries(pgCodec.attributes).reduce((memo, [attributeName, attribute]) => build.recoverable(memo, () => {
                    const action = isPgBaseInput
                        ? "base"
                        : isPgPatch
                            ? "update"
                            : "insert";
                    const fieldBehaviorScope = `attribute:${action}`;
                    if (!build.behavior.pgCodecAttributeMatches([pgCodec, attribute], fieldBehaviorScope)) {
                        return memo;
                    }
                    const fieldName = inflection.attribute({
                        attributeName,
                        codec: pgCodec,
                    });
                    if (memo[fieldName]) {
                        throw new Error(`Two attributes produce the same GraphQL field name '${fieldName}' on input PgCodec '${pgCodec.name}'; one of them is '${attributeName}'`);
                    }
                    const attributeType = build.getGraphQLTypeByPgCodec(attribute.codec, "input");
                    if (!attributeType) {
                        return memo;
                    }
                    return extend(memo, {
                        [fieldName]: fieldWithHooks({
                            fieldName,
                            fieldBehaviorScope,
                            pgCodec,
                            pgAttribute: attribute,
                        }, {
                            description: attribute.description,
                            type: build.nullableIf(isPgBaseInput ||
                                isPgPatch ||
                                (!attribute.notNull &&
                                    !attribute.extensions?.tags?.notNull) ||
                                attribute.hasDefault ||
                                Boolean(attribute.extensions?.tags?.hasDefault), attributeType),
                            autoApplyAfterParentInputPlan: true,
                            autoApplyAfterParentApplyPlan: true,
                            applyPlan: (0, graphile_build_1.EXPORTABLE)((attributeName) => function plan($insert, val) {
                                $insert.set(attributeName, val.get());
                            }, [attributeName]),
                        }),
                    }, `Adding input object field for ${pgCodec.name}.`);
                }), fields);
            },
        },
    },
};
//# sourceMappingURL=PgAttributesPlugin.js.map