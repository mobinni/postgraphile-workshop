"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgBasicsPlugin = void 0;
const tslib_1 = require("tslib");
require("graphile-build");
require("./PgTablesPlugin.js");
require("../interfaces.js");
require("graphile-config");
const pg_sql2_1 = tslib_1.__importDefault(require("pg-sql2"));
const behavior_js_1 = require("../behavior.js");
const inputUtils_js_1 = require("../inputUtils.js");
const version_js_1 = require("../version.js");
exports.PgBasicsPlugin = {
    name: "PgBasicsPlugin",
    description: "Basic utilities required by many other graphile-build-pg plugins.",
    version: version_js_1.version,
    schema: {
        globalBehavior: "connection -list",
        entityBehavior: {
            pgCodec: {
                after: ["default", "inferred"],
                provides: ["override"],
                callback(behavior, codec) {
                    return [behavior, (0, behavior_js_1.getBehavior)(codec.extensions)];
                },
            },
            pgCodecAttribute: {
                after: ["default", "inferred"],
                provides: ["override"],
                callback(behavior, [codec, attribute]) {
                    return [
                        behavior,
                        (0, behavior_js_1.getBehavior)([codec.extensions, attribute.extensions]),
                    ];
                },
            },
            pgResource: {
                after: ["default", "inferred"],
                provides: ["override"],
                callback(behavior, resource) {
                    return [
                        behavior,
                        (0, behavior_js_1.getBehavior)([resource.codec.extensions, resource.extensions]),
                    ];
                },
            },
            pgResourceUnique: {
                after: ["default", "inferred"],
                provides: ["override"],
                callback(behavior, [resource, unique]) {
                    return [
                        behavior,
                        (0, behavior_js_1.getBehavior)([
                            resource.codec.extensions,
                            resource.extensions,
                            unique.extensions,
                        ]),
                    ];
                },
            },
            pgCodecRelation: {
                after: ["default", "inferred"],
                provides: ["override"],
                callback(behavior, relationSpec) {
                    return [
                        behavior,
                        // The behavior is the relation behavior PLUS the remote table
                        // behavior. But the relation settings win.
                        (0, behavior_js_1.getBehavior)([
                            relationSpec.remoteResource.codec.extensions,
                            relationSpec.remoteResource.extensions,
                            relationSpec.extensions,
                        ]),
                    ];
                },
            },
            pgCodecRef: {
                after: ["default", "inferred"],
                provides: ["override"],
                callback(behavior, ref) {
                    return [
                        behavior,
                        (0, behavior_js_1.getBehavior)([ref.definition.extensions, ref.extensions]),
                    ];
                },
            },
            pgRefDefinition: {
                after: ["default", "inferred"],
                provides: ["override"],
                callback(behavior, refSpec) {
                    return [behavior, (0, behavior_js_1.getBehavior)(refSpec.extensions)];
                },
            },
        },
        hooks: {
            build(build) {
                const { graphql: { GraphQLList, GraphQLNonNull }, } = build;
                const pgCodecMetaLookup = (0, inputUtils_js_1.getCodecMetaLookupFromInput)(build.input);
                const getGraphQLTypeNameByPgCodec = (codec, situation) => {
                    if (codec.arrayOfCodec) {
                        throw new Error("Do not use getGraphQLTypeNameByPgCodec with an array type, find the underlying type instead");
                    }
                    const meta = pgCodecMetaLookup.get(codec);
                    if (!meta) {
                        throw new Error(`Codec '${codec.name}' does not have an entry in pgCodecMetaLookup, someone needs to call setGraphQLTypeForPgCodec passing this codec.`);
                    }
                    const typeName = meta.typeNameBySituation[situation] ?? null;
                    return typeName ?? null;
                };
                const getGraphQLTypeByPgCodec = (codec, situation) => {
                    if (!build.status.isInitPhaseComplete) {
                        throw new Error(`Calling build.getGraphQLTypeByPgCodec before the 'init' phase has completed is not allowed.`);
                    }
                    if (codec.arrayOfCodec) {
                        const type = getGraphQLTypeByPgCodec(codec.arrayOfCodec, situation);
                        const nonNull = codec.extensions?.listItemNonNull;
                        return type
                            ? new GraphQLList(nonNull ? new GraphQLNonNull(type) : type)
                            : null;
                    }
                    const typeName = getGraphQLTypeNameByPgCodec(codec, situation);
                    return typeName ? build.getTypeByName(typeName) ?? null : null;
                };
                const hasGraphQLTypeForPgCodec = (codec, situation) => {
                    const meta = pgCodecMetaLookup.get(codec);
                    if (!meta) {
                        return false;
                    }
                    if (situation != null) {
                        const typeName = meta.typeNameBySituation[situation] ?? null;
                        return typeName != null;
                    }
                    else {
                        return Object.keys(meta.typeNameBySituation).length > 0;
                    }
                };
                const setGraphQLTypeForPgCodec = (codec, variants, typeName) => {
                    build.assertTypeName(typeName);
                    let meta = pgCodecMetaLookup.get(codec);
                    if (!meta) {
                        meta = (0, inputUtils_js_1.makePgCodecMeta)(codec);
                        pgCodecMetaLookup.set(codec, meta);
                    }
                    const situations_ = Array.isArray(variants) ? variants : [variants];
                    for (const situation of situations_) {
                        if (meta.typeNameBySituation[situation] != null) {
                            // TODO: allow this?
                            throw new Error("Type already set");
                        }
                        meta.typeNameBySituation[situation] = typeName;
                    }
                };
                return build.extend(build, {
                    pgCodecMetaLookup,
                    getGraphQLTypeNameByPgCodec,
                    getGraphQLTypeByPgCodec,
                    hasGraphQLTypeForPgCodec,
                    setGraphQLTypeForPgCodec,
                    sql: pg_sql2_1.default,
                    pgGetBehavior: behavior_js_1.getBehavior,
                    // For slightly better backwards compatibility with v4.
                    pgSql: pg_sql2_1.default,
                }, "Adding helpers from PgBasicsPlugin");
            },
        },
    },
};
//# sourceMappingURL=PgBasicsPlugin.js.map