import type { PromiseOrDirect, TypedEventEmitter } from "grafast";
import type { GraphQLSchema } from "graphql";
import type { ErrorResult, GrafservConfig, HandlerResult, RequestDigest, Result, SchemaChangeEvent } from "../interfaces.js";
import { makeGraphiQLHandler } from "../middleware/graphiql.js";
import { makeGraphQLHandler } from "../middleware/graphql.js";
import type { OptionsFromConfig } from "../options.js";
export declare class GrafservBase {
    private releaseHandlers;
    private releasing;
    /** @internal */
    dynamicOptions: OptionsFromConfig;
    resolvedPreset: GraphileConfig.ResolvedPreset;
    protected schema: GraphQLSchema | PromiseLike<GraphQLSchema> | null;
    protected schemaError: PromiseLike<GraphQLSchema> | null;
    protected eventEmitter: TypedEventEmitter<{
        "schema:ready": GraphQLSchema;
        "schema:error": any;
    }>;
    private initialized;
    graphqlHandler: ReturnType<typeof makeGraphQLHandler>;
    graphiqlHandler: ReturnType<typeof makeGraphiQLHandler>;
    constructor(config: GrafservConfig);
    private _processRequest;
    protected processRequest(request: RequestDigest): PromiseOrDirect<Result | null>;
    getPreset(): GraphileConfig.ResolvedPreset;
    getSchema(): PromiseOrDirect<GraphQLSchema>;
    release(): Promise<void>;
    onRelease(cb: () => PromiseOrDirect<void>): void;
    setPreset(newPreset: GraphileConfig.Preset): void;
    setSchema(newSchema: GraphQLSchema): void;
    private refreshHandlers;
    makeStream(): AsyncIterableIterator<SchemaChangeEvent>;
}
export declare function convertHandlerResultToResult(handlerResult: HandlerResult | null): PromiseOrDirect<Result | null>;
export declare const handleError: (error: Error & {
    statusCode?: number;
}) => ErrorResult;
//# sourceMappingURL=base.d.ts.map