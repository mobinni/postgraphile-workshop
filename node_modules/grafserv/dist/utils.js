"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGraphQLJSONBody = exports.makeGraphQLWSConfig = exports.httpError = exports.normalizeRequest = exports.memo = exports.getBodyFromFrameworkBody = exports.getBodyFromRequest = exports.processHeaders = exports.handleErrors = void 0;
const tslib_1 = require("tslib");
const grafast_1 = require("grafast");
const graphql = tslib_1.__importStar(require("graphql"));
const hooks_js_1 = require("./hooks.js");
const interfaces_js_1 = require("./interfaces.js");
const graphql_js_1 = require("./middleware/graphql.js");
const { GraphQLError } = graphql;
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
function handleErrors(payload) {
    if ("errors" in payload && payload.errors) {
        payload.errors = payload.errors.map((e) => {
            const obj = e instanceof GraphQLError
                ? e.toJSON()
                : { message: e.message, ...e };
            return Object.assign(obj, {
                message: (0, grafast_1.stripAnsi)(obj.message),
                extensions: {
                    ...(e instanceof GraphQLError ? e.extensions : null),
                    ...(e.stack
                        ? {
                            stack: (0, grafast_1.stripAnsi)(e.stack).split("\n"),
                        }
                        : null),
                    ...(e.cause
                        ? {
                            cause: (0, grafast_1.stripAnsi)(String(e.cause)),
                        }
                        : null),
                },
            });
        });
    }
}
exports.handleErrors = handleErrors;
function processHeaders(headers) {
    const headerDigest = Object.create(null);
    for (const key in headers) {
        const val = headers[key];
        if (val == null) {
            continue;
        }
        if (typeof val === "string") {
            headerDigest[key] = val;
        }
        else {
            headerDigest[key] = val.join("\n");
        }
    }
    return headerDigest;
}
exports.processHeaders = processHeaders;
function getBodyFromRequest(req /* IncomingMessage */, maxLength) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        let len = 0;
        const handleData = (chunk) => {
            chunks.push(chunk);
            len += chunk.length;
            if (len > maxLength) {
                req.off("end", done);
                req.off("error", reject);
                req.off("data", handleData);
                reject(httpError(413, "Too much data"));
            }
        };
        const done = () => {
            resolve({ type: "buffer", buffer: Buffer.concat(chunks) });
        };
        req.on("end", done);
        req.on("error", reject);
        req.on("data", handleData);
    });
}
exports.getBodyFromRequest = getBodyFromRequest;
function getBodyFromFrameworkBody(body) {
    if (typeof body === "string") {
        return {
            type: "text",
            text: body,
        };
    }
    else if (Buffer.isBuffer(body)) {
        return {
            type: "buffer",
            buffer: body,
        };
    }
    else if (typeof body === "object" && body != null) {
        return {
            type: "json",
            json: body,
        };
    }
    else {
        throw new Error(`Grafserv Express adaptor doesn't know how to interpret this request body`);
    }
}
exports.getBodyFromFrameworkBody = getBodyFromFrameworkBody;
function memo(fn) {
    let cache;
    let called = false;
    return function memoized() {
        if (called) {
            return cache;
        }
        else {
            called = true;
            cache = fn.call(this);
            return cache;
        }
    };
}
exports.memo = memo;
function normalizeRequest(request) {
    if (!request[interfaces_js_1.$$normalizedHeaders]) {
        const r = request;
        const normalized = Object.create(null);
        for (const key in r.headers) {
            normalized[key.toLowerCase()] = r.headers[key];
        }
        r[interfaces_js_1.$$normalizedHeaders] = normalized;
        r.preferJSON = Boolean(r.preferJSON);
        r.getHeader = (key) => normalized[key.toLowerCase()];
        r.getBody = memo(r.getBody);
        r.getQueryParams = memo(r.getQueryParams);
        if (r.method === "HEAD") {
            // Pretend that 'HEAD' requests are actually 'GET' requests; Node will
            // take care of stripping the response body for us.
            r.method = "GET";
        }
    }
    return request;
}
exports.normalizeRequest = normalizeRequest;
function httpError(statusCode, message) {
    return new grafast_1.SafeError(message, { statusCode });
}
exports.httpError = httpError;
function makeGraphQLWSConfig(instance) {
    const { resolvedPreset, dynamicOptions: { maskExecutionResult }, } = instance;
    const hooks = (0, hooks_js_1.getGrafservHooks)(resolvedPreset);
    let latestSchema;
    let latestSchemaOrPromise;
    let latestParseAndValidate;
    let schemaPrepare = null;
    return {
        async onSubscribe(ctx, message) {
            // Get up to date schema, in case we're in watch mode
            const schemaOrPromise = instance.getSchema();
            if (schemaOrPromise !== latestSchemaOrPromise) {
                if ("then" in schemaOrPromise) {
                    latestSchemaOrPromise = schemaOrPromise;
                    schemaPrepare = (async () => {
                        latestSchema = await schemaOrPromise;
                        latestSchemaOrPromise = schemaOrPromise;
                        latestParseAndValidate = (0, graphql_js_1.makeParseAndValidateFunction)(latestSchema);
                        schemaPrepare = null;
                        return true;
                    })();
                }
                else {
                    latestSchemaOrPromise = schemaOrPromise;
                    if (latestSchema === schemaOrPromise) {
                        // No action necessary
                    }
                    else {
                        latestSchema = schemaOrPromise;
                        latestParseAndValidate = (0, graphql_js_1.makeParseAndValidateFunction)(latestSchema);
                    }
                }
            }
            if (schemaPrepare !== null) {
                const schemaReady = await Promise.race([
                    schemaPrepare,
                    sleep(instance.dynamicOptions.schemaWaitTime),
                ]);
                if (schemaReady !== true) {
                    // Handle missing schema
                    throw new Error(`Schema isn't ready`);
                }
            }
            const schema = latestSchema;
            const parseAndValidate = latestParseAndValidate;
            const parsedBody = parseGraphQLJSONBody(message.payload);
            await hooks.process("processGraphQLRequestBody", {
                body: parsedBody,
                graphqlWsContext: ctx,
            });
            const { query, operationName, variableValues } = (0, graphql_js_1.validateGraphQLBody)(parsedBody);
            const { errors, document } = parseAndValidate(query);
            if (errors !== undefined) {
                return errors;
            }
            const args = {
                schema,
                document,
                rootValue: null,
                contextValue: Object.create(null),
                variableValues,
                operationName,
            };
            await (0, grafast_1.hookArgs)(args, resolvedPreset, {
                ws: {
                    request: ctx.extra.request,
                    socket: ctx.extra.socket,
                    connectionParams: ctx.connectionParams,
                },
            });
            return args;
        },
        async execute(args) {
            return maskExecutionResult(await (0, grafast_1.execute)(args, resolvedPreset));
        },
        async subscribe(args) {
            return maskExecutionResult(await (0, grafast_1.subscribe)(args, resolvedPreset));
        },
    };
}
exports.makeGraphQLWSConfig = makeGraphQLWSConfig;
function parseGraphQLJSONBody(params) {
    if (!params) {
        throw httpError(400, "No body");
    }
    if (typeof params !== "object" || Array.isArray(params)) {
        throw httpError(400, "Invalid body; expected object");
    }
    const id = params.id;
    const documentId = params.documentId;
    const query = params.query;
    const operationName = params.operationName ?? undefined;
    const variableValues = params.variables ?? undefined;
    const extensions = params.extensions ?? undefined;
    return {
        id,
        documentId,
        query,
        operationName,
        variableValues,
        extensions,
    };
}
exports.parseGraphQLJSONBody = parseGraphQLJSONBody;
//# sourceMappingURL=utils.js.map