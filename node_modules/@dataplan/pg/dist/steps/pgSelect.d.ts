import type { ConnectionCapableStep, ExecutionExtra, GrafastResultsList, GrafastResultStreamList, GrafastValuesList, InputStep, LambdaStep, StepOptimizeOptions, StreamableStep } from "grafast";
import { __InputStaticLeafStep, ConnectionStep, ExecutableStep } from "grafast";
import type { SQL } from "pg-sql2";
import type { PgCodecAttributes } from "../codecs.js";
import type { PgResource } from "../datasource.js";
import type { GetPgResourceAttributes, GetPgResourceCodec, GetPgResourceRelations, PgCodec, PgGroupSpec, PgOrderSpec, PgTypedExecutableStep } from "../interfaces.js";
import { PgClassExpressionStep } from "./pgClassExpression.js";
import type { PgHavingConditionSpec, PgWhereConditionSpec } from "./pgCondition.js";
import { PgConditionStep } from "./pgCondition.js";
import type { PgPageInfoStep } from "./pgPageInfo.js";
import type { PgSelectSinglePlanOptions } from "./pgSelectSingle.js";
import { PgSelectSingleStep } from "./pgSelectSingle.js";
export type PgSelectParsedCursorStep = LambdaStep<string, any[]>;
type PgSelectPlanJoin = {
    type: "cross";
    from: SQL;
    alias: SQL;
    attributeNames?: SQL;
    lateral?: boolean;
} | {
    type: "inner" | "left" | "right" | "full";
    from: SQL;
    alias: SQL;
    attributeNames?: SQL;
    conditions: SQL[];
    lateral?: boolean;
};
export type PgSelectIdentifierSpec = {
    step: ExecutableStep;
    codec: PgCodec;
    matches: (alias: SQL) => SQL;
} | {
    step: PgTypedExecutableStep<any>;
    codec?: PgCodec;
    matches: (alias: SQL) => SQL;
};
export type PgSelectArgumentSpec = {
    step: ExecutableStep;
    pgCodec: PgCodec<any, any, any, any>;
    name?: string;
} | {
    step: PgTypedExecutableStep<any>;
    name?: string;
};
export interface PgSelectArgumentDigest {
    position?: number;
    name?: string;
    placeholder: SQL;
}
export type PgSelectMode = "normal" | "aggregate" | "mutation";
export interface PgSelectOptions<TResource extends PgResource<any, any, any, any, any> = PgResource> {
    resource: TResource;
    identifiers: Array<PgSelectIdentifierSpec>;
    args?: Array<PgSelectArgumentSpec>;
    from?: SQL | ((...args: PgSelectArgumentDigest[]) => SQL);
    name?: string;
    mode?: PgSelectMode;
    joinAsLateral?: boolean;
}
export declare class PgSelectStep<TResource extends PgResource<any, any, any, any, any> = PgResource> extends ExecutableStep<ReadonlyArray<unknown[]>> implements StreamableStep<unknown[]>, ConnectionCapableStep<PgSelectSingleStep<TResource>, PgSelectParsedCursorStep> {
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    private readonly from;
    private readonly name;
    private readonly symbol;
    private readonly _symbolSubstitutes;
    readonly alias: SQL;
    readonly resource: TResource;
    private relationJoins;
    private joins;
    private conditions;
    private groups;
    private havingConditions;
    private orders;
    private isOrderUnique;
    private first;
    private last;
    private fetchOneExtra;
    private lowerIndexStepId;
    private upperIndexStepId;
    private limitAndOffsetId;
    private offset;
    private beforeStepId;
    private afterStepId;
    private connectionDepId;
    private queryValues;
    private identifierMatches;
    private arguments;
    private placeholders;
    private placeholderValues;
    private isTrusted;
    private isUnique;
    private isInliningForbidden;
    private joinAsLateral;
    private selects;
    private contextId;
    private streamOptions;
    private finalizeResults;
    readonly mode: PgSelectMode;
    private locker;
    constructor(options: PgSelectOptions<TResource>);
    constructor(cloneFrom: PgSelectStep<TResource>, mode?: PgSelectMode);
    toStringMeta(): string;
    lock(): void;
    setInliningForbidden(newInliningForbidden?: boolean): this;
    inliningForbidden(): boolean;
    setTrusted(newIsTrusted?: boolean): this;
    trusted(): boolean;
    setFirst(first: InputStep): this;
    setLast(last: InputStep): this;
    setOffset(offset: InputStep): this;
    setUnique(newUnique?: boolean): this;
    hasMore(): ExecutableStep<boolean>;
    unique(): boolean;
    placeholder($step: PgTypedExecutableStep<PgCodec>): SQL;
    placeholder($step: ExecutableStep, codec: PgCodec): SQL;
    singleRelation<TRelationName extends keyof GetPgResourceRelations<TResource> & string>(relationIdentifier: TRelationName): SQL;
    join(spec: PgSelectPlanJoin): void;
    selectAndReturnIndex(fragment: SQL): number;
    private nullCheckIndex;
    getNullCheckIndex(): number | null;
    clone(mode?: PgSelectMode): PgSelectStep<TResource>;
    connectionClone($connection: ConnectionStep<any, any, any, any>, mode?: PgSelectMode): PgSelectStep<TResource>;
    where(condition: PgWhereConditionSpec<keyof GetPgResourceAttributes<TResource> & string>): void;
    wherePlan(): PgConditionStep<this>;
    groupBy(group: PgGroupSpec): void;
    getGroups(): readonly PgGroupSpec[];
    havingPlan(): PgConditionStep<this>;
    having(condition: PgHavingConditionSpec<keyof GetPgResourceAttributes<TResource> & string>): void;
    orderBy(order: PgOrderSpec): void;
    orderIsUnique(): boolean;
    setOrderIsUnique(): void;
    private assertCursorPaginationAllowed;
    private applyConditionFromCursor;
    parseCursor($cursorPlan: __InputStaticLeafStep<string>): PgSelectParsedCursorStep | null;
    setAfter($parsedCursorPlan: PgSelectParsedCursorStep): void;
    setBefore($parsedCursorPlan: PgSelectParsedCursorStep): void;
    pageInfo($connectionPlan: ConnectionStep<any, PgSelectParsedCursorStep, this, any>): PgPageInfoStep<this>;
    isNullFetch(): boolean;
    execute(count: number, values: Array<GrafastValuesList<any>>, { eventEmitter }: ExecutionExtra): Promise<GrafastResultsList<ReadonlyArray<unknown[]>>>;
    stream(_count: number, values: ReadonlyArray<GrafastValuesList<any>>, { eventEmitter }: ExecutionExtra): Promise<GrafastResultStreamList<unknown[]>>;
    private buildSelect;
    private fromExpression;
    private buildFrom;
    private buildJoin;
    private buildWhereOrHaving;
    getOrderByDigest(): string;
    getOrderBy(): ReadonlyArray<PgOrderSpec>;
    private shouldReverseOrder;
    private buildGroupBy;
    private buildOrderBy;
    private limitAndOffsetSQL;
    private planLimitAndOffset;
    private buildLimitAndOffset;
    private buildQuery;
    finalize(): void;
    deduplicate(peers: PgSelectStep<any>[]): PgSelectStep<TResource>[];
    deduplicatedWith(replacement: PgSelectStep<TResource>): void;
    private mergeSelectsWith;
    private mergePlaceholdersInto;
    optimize({ stream }: StepOptimizeOptions): ExecutableStep;
    singleAsRecord(options?: PgSelectSinglePlanOptions): PgSelectSingleStep<TResource>;
    single(options?: PgSelectSinglePlanOptions): TResource extends PgResource<any, PgCodec<any, infer UAttributes, any, any, any, any, any>, any, any, any> ? UAttributes extends PgCodecAttributes ? PgSelectSingleStep<TResource> : PgClassExpressionStep<PgCodec<string, undefined, any, any, any, any, any>, TResource> : never;
    row($row: ExecutableStep, options?: PgSelectSinglePlanOptions): PgSelectSingleStep<TResource>;
    listItem(itemPlan: ExecutableStep): TResource extends PgResource<any, PgCodec<any, infer UAttributes, any, any, any, any, any>, any, any, any> ? UAttributes extends PgCodecAttributes ? PgSelectSingleStep<TResource> : PgClassExpressionStep<PgCodec<string, undefined, any, any, any, any, any>, TResource> : never;
}
export declare function pgSelect<TResource extends PgResource<any, any, any, any, any>>(options: PgSelectOptions<TResource>): PgSelectStep<TResource>;
export declare function pgSelectFromRecords<TResource extends PgResource<any, any, any, any, any>>(resource: TResource, records: PgClassExpressionStep<PgCodec<any, undefined, any, any, GetPgResourceCodec<TResource>, any, any>, TResource>): PgSelectStep<TResource>;
export declare function sqlFromArgDigests(digests: readonly PgSelectArgumentDigest[]): SQL;
export declare function digestsFromArgumentSpecs($placeholderable: {
    placeholder(step: ExecutableStep, codec: PgCodec): SQL;
}, specs: PgSelectArgumentSpec[], digests?: PgSelectArgumentDigest[], initialArgIndex?: number | null): {
    digests: PgSelectArgumentDigest[];
    argIndex: number | null;
};
export declare function getFragmentAndCodecFromOrder(alias: SQL, order: PgOrderSpec, codec: PgCodec): [SQL, PgCodec];
export {};
//# sourceMappingURL=pgSelect.d.ts.map