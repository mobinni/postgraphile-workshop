import type { ExecutionExtra } from "grafast";
import { UnbatchedExecutableStep } from "grafast";
import type { SQL } from "pg-sql2";
import type { PgResource } from "../datasource.js";
import type { GetPgCodecAttributes, PgClassSingleStep, PgCodec, PgTypedExecutableStep } from "../interfaces.js";
import { PgUnionAllSingleStep } from "./pgUnionAll.js";
export declare class PgClassExpressionStep<TExpressionCodec extends PgCodec, TResource extends PgResource<any, any, any, any, any>> extends UnbatchedExecutableStep<any> implements PgTypedExecutableStep<TExpressionCodec> {
    readonly pgCodec: TExpressionCodec;
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    readonly rowDependencyId: number;
    private attrIndex;
    readonly expression: SQL;
    private needsPolymorphicUnwrap;
    constructor($table: PgClassSingleStep<TResource> | PgUnionAllSingleStep, pgCodec: TExpressionCodec, strings: TemplateStringsArray, dependencies?: ReadonlyArray<PgTypedExecutableStep<any> | SQL>);
    toStringMeta(): string;
    get<TAttr extends keyof GetPgCodecAttributes<TExpressionCodec>>(attributeName: TAttr): PgClassExpressionStep<GetPgCodecAttributes<TExpressionCodec>[TAttr]["codec"], TResource>;
    getParentStep(): PgClassSingleStep<TResource> | PgUnionAllSingleStep;
    optimize(): this;
    unbatchedExecute(_extra: ExecutionExtra, v: any): any;
    deduplicate(peers: Array<PgClassExpressionStep<any, any>>): PgClassExpressionStep<TExpressionCodec, TResource>[];
    toSQL(): SQL;
}
declare function pgClassExpression<TExpressionCodec extends PgCodec, TResource extends PgResource<any, any, any, any, any>>(table: PgClassSingleStep<TResource> | PgUnionAllSingleStep, codec: TExpressionCodec): (strings: TemplateStringsArray, ...dependencies: ReadonlyArray<PgTypedExecutableStep<any> | SQL>) => PgClassExpressionStep<TExpressionCodec, TResource>;
export { pgClassExpression };
//# sourceMappingURL=pgClassExpression.d.ts.map