import type { BaseStep, ExecutableStep } from "grafast";
import { ModifierStep } from "grafast";
import type { SQL } from "pg-sql2";
import type { PgCodec } from "../interfaces.js";
export type PgWhereConditionSpec<TAttribute extends string> = SQL | {
    type: "attribute";
    attribute: TAttribute;
    callback: (fragment: SQL) => SQL;
};
export type PgHavingConditionSpec<_TAttribute extends string> = SQL;
export interface PgConditionStepExtensions {
}
export interface PgConditionCapableParentStep extends BaseStep {
    alias: SQL;
    placeholder($step: ExecutableStep, codec: PgCodec): SQL;
    where(condition: PgWhereConditionSpec<any>): void;
    having?(condition: PgHavingConditionSpec<any>): void;
}
type PgConditionStepModeExists = {
    mode: "EXISTS";
    tableExpression: SQL;
    alias?: string;
    $equals?: ExecutableStep;
};
export type PgConditionStepResolvedMode = {
    mode: "PASS_THRU";
} | {
    mode: "AND";
} | {
    mode: "OR";
} | {
    mode: "NOT";
} | PgConditionStepModeExists;
export type PgConditionStepMode = "PASS_THRU" | "AND" | "OR" | "NOT" | PgConditionStepResolvedMode;
export declare class PgConditionStep<TParentStep extends PgConditionCapableParentStep = PgConditionCapableParentStep> extends ModifierStep<TParentStep> implements PgConditionCapableParentStep {
    private isHaving;
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    private conditions;
    private havingConditions;
    readonly alias: SQL;
    extensions: PgConditionStepExtensions;
    private mode;
    constructor($parent: TParentStep, isHaving?: boolean, mode?: PgConditionStepMode);
    toStringMeta(): string;
    orPlan(): PgConditionStep<this>;
    andPlan(): PgConditionStep<this>;
    notPlan(): PgConditionStep<this>;
    existsPlan(options: Omit<PgConditionStepModeExists, "mode">): PgConditionStep<this>;
    where(condition: PgWhereConditionSpec<any>): void;
    having(condition: PgHavingConditionSpec<any>): void;
    placeholder($step: ExecutableStep, codec: PgCodec): SQL;
    private transform;
    apply(): void;
}
export declare function pgWhereConditionSpecListToSQL(alias: SQL, conditions: PgWhereConditionSpec<any>[], andOr?: "and" | "or", transform?: (frag: SQL) => SQL): SQL | null;
export {};
//# sourceMappingURL=pgCondition.d.ts.map