import type { __InputStaticLeafStep, ConnectionCapableStep, ConnectionStep, EdgeCapableStep, ExecutionExtra, GrafastResultsList, GrafastValuesList, InputStep, PolymorphicStep } from "grafast";
import { ExecutableStep } from "grafast";
import type { GraphQLObjectType } from "graphql";
import type { SQL } from "pg-sql2";
import type { PgResource, PgResourceUnique } from "../datasource.js";
import type { PgCodecRefPath, PgGroupSpec } from "../index.js";
import type { PgCodec, PgOrderFragmentSpec, PgTypedExecutableStep } from "../interfaces.js";
import type { PgClassExpressionStep } from "./pgClassExpression.js";
import type { PgHavingConditionSpec, PgWhereConditionSpec } from "./pgCondition.js";
import { PgConditionStep } from "./pgCondition.js";
import { PgCursorStep } from "./pgCursor.js";
import type { PgPageInfoStep } from "./pgPageInfo.js";
import type { PgSelectParsedCursorStep } from "./pgSelect.js";
import type { PgSelectSingleStep } from "./pgSelectSingle.js";
export type PgUnionAllStepConfigAttributes<TAttributes extends string> = {
    [attributeName in TAttributes]: {
        codec: PgCodec;
    };
};
export interface PgUnionAllStepMember<TTypeNames extends string> {
    typeName: TTypeNames;
    resource: PgResource<any, any, ReadonlyArray<PgResourceUnique<any>>, any, any>;
    match?: {
        [resourceAttributeName: string]: {
            step: PgTypedExecutableStep<any>;
            codec?: never;
        } | {
            step: ExecutableStep;
            codec: PgCodec;
        };
    };
    path?: PgCodecRefPath;
}
export interface PgUnionAllStepConfig<TAttributes extends string, TTypeNames extends string> {
    resourceByTypeName: {
        [typeName in TTypeNames]: PgResource<any, any, any, any, any>;
    };
    attributes?: PgUnionAllStepConfigAttributes<TAttributes>;
    members?: PgUnionAllStepMember<TTypeNames>[];
    mode?: PgUnionAllMode;
}
export interface PgUnionAllStepCondition<TAttributes extends string> {
    attribute: TAttributes;
    callback: (fragment: SQL) => SQL;
}
export interface PgUnionAllStepOrder<TAttributes extends string> {
    attribute: TAttributes;
    direction: "ASC" | "DESC";
}
export declare class PgUnionAllSingleStep extends ExecutableStep implements PolymorphicStep, EdgeCapableStep<any> {
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    private typeKey;
    private pkKey;
    private readonly spec;
    constructor($parent: PgUnionAllStep<any, any>, $item: ExecutableStep);
    planForType(objectType: GraphQLObjectType<any, any>): ExecutableStep;
    getCursorDigestAndStep(): [string, ExecutableStep];
    cursor(): PgCursorStep<this>;
    getClassStep(): PgUnionAllStep<string, string>;
    node(): this;
    expression<TExpressionCodec extends PgCodec>(expression: SQL, codec: TExpressionCodec): PgClassExpressionStep<TExpressionCodec, any>;
    selectAndReturnIndex(fragment: SQL): number;
    select<TExpressionCodec extends PgCodec>(fragment: SQL, codec: TExpressionCodec): PgClassExpressionStep<TExpressionCodec, any>;
    execute(_count: number, values: [GrafastValuesList<any>]): GrafastResultsList<any>;
}
export type PgUnionAllMode = "normal" | "aggregate";
export declare class PgUnionAllStep<TAttributes extends string = string, TTypeNames extends string = string> extends ExecutableStep implements ConnectionCapableStep<PgSelectSingleStep<any>, PgSelectParsedCursorStep> {
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    symbol: symbol;
    alias: SQL;
    private selects;
    private executor;
    private contextId;
    readonly spec: PgUnionAllStepConfig<TAttributes, TTypeNames>;
    orders: Array<PgOrderFragmentSpec>;
    private orderSelectIndex;
    private ordersForCursor;
    private queryValues;
    private placeholders;
    private placeholderValues;
    private groups;
    private havingConditions;
    private first;
    private last;
    private fetchOneExtra;
    private lowerIndexStepId;
    private upperIndexStepId;
    private limitAndOffsetId;
    private offset;
    private beforeStepId;
    private afterStepId;
    private connectionDepId;
    private finalizeResults;
    private limitAndOffsetSQL;
    private innerLimitSQL;
    readonly mode: PgUnionAllMode;
    private locker;
    private memberDigests;
    constructor(cloneFrom: PgUnionAllStep<TAttributes, TTypeNames>, mode?: PgUnionAllMode);
    constructor(spec: PgUnionAllStepConfig<TAttributes, TTypeNames>);
    connectionClone($connection: ConnectionStep<any, any, any, any>, mode?: PgUnionAllMode): PgUnionAllStep<TAttributes, TTypeNames>;
    select<TAttribute extends TAttributes>(key: TAttribute): number;
    selectAndReturnIndex(fragment: SQL): number;
    selectPk(): number;
    selectExpression(expression: SQL, codec: PgCodec): number;
    selectType(): number;
    selectOrderValue(orderIndex: number): number;
    singleAsRecord(): PgUnionAllSingleStep;
    single(): PgUnionAllSingleStep;
    row($row: ExecutableStep): PgUnionAllSingleStep;
    listItem(itemPlan: ExecutableStep): any;
    pageInfo($connectionPlan: ConnectionStep<any, PgSelectParsedCursorStep, this, any>): PgPageInfoStep<this>;
    where(whereSpec: PgWhereConditionSpec<TAttributes>): void;
    wherePlan(): PgConditionStep<this>;
    groupBy(group: PgGroupSpec): void;
    havingPlan(): PgConditionStep<this>;
    having(condition: PgHavingConditionSpec<string>): void;
    orderBy(orderSpec: PgUnionAllStepOrder<TAttributes>): void;
    setOrderIsUnique(): void;
    private assertCursorPaginationAllowed;
    hasMore(): ExecutableStep<boolean>;
    placeholder($step: PgTypedExecutableStep<any>): SQL;
    placeholder($step: ExecutableStep, codec: PgCodec): SQL;
    private applyConditionFromCursor;
    parseCursor($cursorPlan: __InputStaticLeafStep<string>): PgSelectParsedCursorStep | null;
    setAfter($parsedCursorPlan: PgSelectParsedCursorStep): void;
    setBefore($parsedCursorPlan: PgSelectParsedCursorStep): void;
    private shouldReverseOrder;
    setFirst(first: InputStep | number): this;
    setLast(last: InputStep | number): this;
    setOffset(offset: InputStep | number): this;
    private planLimitAndOffset;
    getOrderByDigest(): string;
    getOrderBy(): ReadonlyArray<PgOrderFragmentSpec>;
    getOrderByWithoutType(): ReadonlyArray<PgOrderFragmentSpec>;
    optimize(): this | import("grafast").ConstantStep<never[]>;
    finalize(): void;
    execute(_count: number, values: Array<GrafastValuesList<any>>, { eventEmitter }: ExecutionExtra): Promise<GrafastValuesList<any>>;
}
export declare function pgUnionAll<TAttributes extends string, TTypeNames extends string>(spec: PgUnionAllStepConfig<TAttributes, TTypeNames>): PgUnionAllStep<TAttributes, TTypeNames>;
//# sourceMappingURL=pgUnionAll.d.ts.map