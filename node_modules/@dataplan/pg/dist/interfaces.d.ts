import type { ExecutableStep, GrafastSubscriber, ModifierStep } from "grafast";
import type { SQL, SQLRawValue } from "pg-sql2";
import type { PgAdaptorOptions } from "./adaptors/pg.js";
import type { PgCodecAttributes } from "./codecs.js";
import type { PgCodecRefs, PgResource, PgResourceOptions, PgResourceParameter, PgResourceUnique } from "./datasource.js";
import type { WithPgClient } from "./executor.js";
import type { PgDeleteSingleStep } from "./steps/pgDeleteSingle.js";
import type { PgInsertSingleStep } from "./steps/pgInsertSingle.js";
import type { PgSelectSingleStep } from "./steps/pgSelectSingle.js";
import type { PgUpdateSingleStep } from "./steps/pgUpdateSingle.js";
export type PgClassSingleStep<TResource extends PgResource<any, any, any, any, any> = PgResource> = PgSelectSingleStep<TResource> | PgInsertSingleStep<TResource> | PgUpdateSingleStep<TResource> | PgDeleteSingleStep<TResource>;
export type PgEncode<TInput> = (value: TInput) => SQLRawValue;
export type PgDecode<TForJavaScript, TFromPostgres = string> = (value: TFromPostgres) => TForJavaScript;
export interface PgRefDefinitionExtensions {
}
export interface PgRefDefinition {
    graphqlType?: string;
    singular?: boolean;
    description?: string;
    extensions?: PgRefDefinitionExtensions;
    singleRecordFieldName?: string;
    listFieldName?: string;
    connectionFieldName?: string;
}
export interface PgRefDefinitions {
    [refName: string]: PgRefDefinition;
}
export interface PgCodecExtensions {
    oid?: string;
    pg?: {
        serviceName: string;
        schemaName: string;
        name: string;
    };
    listItemNonNull?: boolean;
}
export interface PgCodecPolymorphismSingleTypeAttributeSpec<TAttributeName extends string = string> {
    attribute: TAttributeName;
    isNotNull?: boolean;
    rename?: string;
}
export interface PgCodecPolymorphismSingleTypeSpec<TAttributeName extends string = string> {
    name: string;
    attributes: Array<PgCodecPolymorphismSingleTypeAttributeSpec<TAttributeName>>;
}
export interface PgCodecPolymorphismSingle<TAttributeName extends string = string> {
    mode: "single";
    typeAttributes: readonly TAttributeName[];
    commonAttributes: readonly TAttributeName[];
    types: {
        [typeKey: string]: PgCodecPolymorphismSingleTypeSpec<TAttributeName>;
    };
}
export interface PgCodecPolymorphismRelationalTypeSpec {
    name: string;
    references: string;
    relationName: string;
}
export interface PgCodecPolymorphismRelational<TAttributeName extends string = string> {
    mode: "relational";
    typeAttributes: readonly TAttributeName[];
    types: {
        [typeKey: string]: PgCodecPolymorphismRelationalTypeSpec;
    };
}
export interface PgCodecPolymorphismUnion {
    mode: "union";
}
export type PgCodecPolymorphism<TAttributeName extends string> = PgCodecPolymorphismSingle<TAttributeName> | PgCodecPolymorphismRelational<TAttributeName> | PgCodecPolymorphismUnion;
export interface PgCodec<TName extends string = string, TAttributes extends PgCodecAttributes | undefined = PgCodecAttributes | undefined, TFromPostgres = any, TFromJavaScript = TFromPostgres, TArrayItemCodec extends PgCodec<string, any, any, any, undefined, any, any> | undefined = PgCodec<string, any, any, any, undefined, any, any> | undefined, TDomainItemCodec extends PgCodec<string, any, any, any, any, any, any> | undefined = PgCodec<string, any, any, any, any, any, any> | undefined, TRangeItemCodec extends PgCodec<string, undefined, any, any, undefined, any, undefined> | undefined = PgCodec<string, undefined, any, any, undefined, any, undefined> | undefined> {
    name: TName;
    toPg: PgEncode<TFromJavaScript>;
    fromPg: PgDecode<TFromJavaScript, TFromPostgres>;
    castFromPg?: (fragment: SQL) => SQL;
    listCastFromPg?: (fragment: SQL) => SQL;
    sqlType: SQL;
    isAnonymous?: boolean;
    attributes: TAttributes;
    notNullExpression?: (alias: SQL) => SQL;
    arrayOfCodec?: TArrayItemCodec;
    domainOfCodec?: TDomainItemCodec;
    notNull?: boolean;
    rangeOfCodec?: TRangeItemCodec;
    polymorphism?: PgCodecPolymorphism<any>;
    description?: string;
    extensions?: Partial<PgCodecExtensions>;
    refs?: PgCodecRefs;
}
export type PgCodecWithAttributes<TAttributes extends PgCodecAttributes = PgCodecAttributes> = PgCodec<any, TAttributes, any, any, undefined, any, undefined>;
export type PgCodecAnyScalar = PgCodec<string, undefined, any, any, undefined, any, any>;
export type PgCodecList<TInnerCodec extends PgCodec<string, any, any, any, undefined, any, any> = PgCodec<string, any, any, any, undefined, any, any>> = PgCodec<string, undefined, any, any, TInnerCodec, undefined, undefined>;
export type PgEnumValue<TValue extends string = string> = {
    value: TValue;
    description?: string;
};
export interface PgEnumCodec<TName extends string = string, TValue extends string = string> extends PgCodec<TName, undefined, string, TValue, undefined, undefined, undefined> {
    values: PgEnumValue<TValue>[];
}
export interface PgTypedExecutableStep<TCodec extends PgCodec> extends ExecutableStep {
    pgCodec: TCodec;
}
type PgOrderCommonSpec = {
    direction: "ASC" | "DESC";
    nulls?: "FIRST" | "LAST" | null;
};
export type PgOrderFragmentSpec = {
    fragment: SQL;
    codec: PgCodec<string, any, any, any, any, any, any>;
    attribute?: never;
    callback?: never;
} & PgOrderCommonSpec;
export type PgOrderAttributeSpec = {
    attribute: string;
    callback?: (attributeExpression: SQL, attributeCodec: PgCodec) => [SQL, PgCodec];
    fragment?: never;
    codec?: never;
} & PgOrderCommonSpec;
export type PgOrderSpec = PgOrderFragmentSpec | PgOrderAttributeSpec;
export interface PgGroupSpec {
    fragment: SQL;
}
export type TuplePlanMap<TAttributes extends PgCodecAttributes, TTuple extends ReadonlyArray<keyof TAttributes>> = {
    [Index in keyof TTuple]: {
        [key in keyof TAttributes as Exclude<key, keyof TTuple[number]>]?: ExecutableStep<ReturnType<TAttributes[key]["codec"]["fromPg"]>>;
    } & {
        [key in TTuple[number]]: ExecutableStep<ReturnType<TAttributes[key]["codec"]["fromPg"]>>;
    };
};
export type PlanByUniques<TAttributes extends PgCodecAttributes, TUniqueAttributes extends ReadonlyArray<PgResourceUnique<TAttributes>>> = TAttributes extends PgCodecAttributes ? TuplePlanMap<TAttributes, TUniqueAttributes[number]["attributes"] & string[]>[number] : undefined;
export type PgConditionLikeStep = (ModifierStep<any> | ExecutableStep) & {
    alias: SQL;
    placeholder($step: ExecutableStep, codec: PgCodec): SQL;
    where(condition: SQL): void;
    having(condition: SQL): void;
};
export type KeysOfType<TObject, TValueType> = {
    [key in keyof TObject]: TObject[key] extends TValueType ? key : never;
}[keyof TObject];
declare global {
    namespace GraphileConfig {
        interface PgServiceConfiguration<TAdaptor extends keyof GraphileConfig.PgDatabaseAdaptorOptions = keyof GraphileConfig.PgDatabaseAdaptorOptions> {
            name: string;
            schemas?: string[];
            adaptor: TAdaptor;
            adaptorSettings?: GraphileConfig.PgDatabaseAdaptorOptions[TAdaptor];
            withPgClientKey: KeysOfType<Grafast.Context & object, WithPgClient>;
            pgSettings?: (requestContext: Grafast.RequestContext) => {
                [key: string]: string;
            } | null;
            pgSettingsForIntrospection?: {
                [key: string]: string;
            } | null;
            pgSettingsKey?: KeysOfType<Grafast.Context & object, {
                [key: string]: string;
            } | null | undefined>;
            pgSubscriber?: GrafastSubscriber<Record<string, string>> | null;
            pgSubscriberKey?: KeysOfType<Grafast.Context & object, GrafastSubscriber<any> | null | undefined>;
        }
        interface Preset {
            pgServices?: ReadonlyArray<PgServiceConfiguration>;
        }
        interface PgDatabaseAdaptorOptions {
            "@dataplan/pg/adaptors/pg": PgAdaptorOptions;
        }
    }
}
export interface MakePgServiceOptions extends Partial<Pick<GraphileConfig.PgServiceConfiguration, "name" | "pgSettings" | "pgSettingsForIntrospection" | "withPgClientKey" | "pgSettingsKey" | "pgSubscriber" | "pgSubscriberKey">> {
    connectionString?: string;
    schemas?: string | string[];
    superuserConnectionString?: string;
    pubsub?: boolean;
}
export interface PgCodecRelationExtensions {
}
export interface PgCodecRelationBase<TLocalCodec extends PgCodec = PgCodec, TRemoteAttributes extends string = string> {
    localCodec: TLocalCodec;
    localCodecPolymorphicTypes?: string[];
    localAttributes: readonly (keyof TLocalCodec["attributes"])[];
    remoteAttributes: readonly TRemoteAttributes[];
    isUnique: boolean;
    isReferencee?: boolean;
    extensions?: PgCodecRelationExtensions;
    description?: string;
}
export interface PgCodecRelationConfig<TLocalCodec extends PgCodec = PgCodecWithAttributes, TRemoteResourceOptions extends PgResourceOptions = PgResourceOptions<any, PgCodecWithAttributes, any, any>> extends PgCodecRelationBase<TLocalCodec, TRemoteResourceOptions extends PgResourceOptions<any, PgCodec<any, infer UAttributes, any, any, any, any, any>, any, any> ? keyof UAttributes : never> {
    remoteResourceOptions: TRemoteResourceOptions;
}
export interface PgCodecRelation<TLocalCodec extends PgCodecWithAttributes = PgCodecWithAttributes, TRemoteResource extends PgResource<any, PgCodecWithAttributes, any, any, any> = PgResource<any, PgCodecWithAttributes, any, any, any>> extends PgCodecRelationBase<TLocalCodec, TRemoteResource extends PgResource<any, PgCodec<any, infer UAttributes, any, any, any, any, any>, any, any, any> ? keyof UAttributes : never> {
    remoteResource: TRemoteResource;
}
export interface PgRegistryConfig<TCodecs extends {
    [name in string]: PgCodec<name, PgCodecAttributes | undefined, any, any, any, any, any>;
}, TResourceOptions extends {
    [name in string]: PgResourceOptions<name, PgCodec, ReadonlyArray<PgResourceUnique<PgCodecAttributes<any>>>, readonly PgResourceParameter[] | undefined>;
}, TRelations extends {
    [codecName in keyof TCodecs]?: {
        [relationName in string]: PgCodecRelationConfig<PgCodec<string, PgCodecAttributes, any, any, undefined, any, undefined>, PgResourceOptions<any, PgCodecWithAttributes, any, any>>;
    };
}> {
    pgCodecs: TCodecs;
    pgResources: TResourceOptions;
    pgRelations: TRelations;
}
export type Expand<T> = T extends unknown ? {
    [TKey in keyof T]: T[TKey];
} : never;
export interface PgRegistry<TCodecs extends {
    [name in string]: PgCodec<name, PgCodecAttributes | undefined, any, any, any, any, any>;
} = Record<string, PgCodec<string, PgCodecAttributes | undefined, any, any, any, any, any>>, TResourceOptions extends {
    [name in string]: PgResourceOptions<name, PgCodec, ReadonlyArray<PgResourceUnique<PgCodecAttributes>>, readonly PgResourceParameter[] | undefined>;
} = Record<string, PgResourceOptions<string, PgCodecWithAttributes, ReadonlyArray<PgResourceUnique<PgCodecAttributes>>, readonly PgResourceParameter[] | undefined>>, TRelations extends {
    [codecName in keyof TCodecs]?: {
        [relationName in string]: PgCodecRelationConfig<PgCodec<string, PgCodecAttributes, any, any, undefined, any, undefined>, PgResourceOptions<any, PgCodecWithAttributes, any, any>>;
    };
} = Record<string, Record<string, PgCodecRelationConfig<PgCodec<string, PgCodecAttributes, any, any, undefined, any, undefined>, PgResourceOptions<any, PgCodecWithAttributes, any, any>>>>> {
    pgCodecs: TCodecs;
    pgResources: {
        [name in keyof TResourceOptions]: TResourceOptions[name] extends PgResourceOptions<infer UName, infer UCodec, infer UUniques, infer UParameters> ? PgResource<UName, UCodec, UUniques, UParameters, PgRegistry<TCodecs, TResourceOptions, TRelations>> : never;
    };
    pgRelations: {
        [codecName in keyof TRelations]: {
            [relationName in keyof TRelations[codecName]]: Expand<Omit<TRelations[codecName][relationName], "remoteResourceOptions"> & {
                remoteResource: TRelations[codecName][relationName] extends {
                    remoteResourceOptions: PgResourceOptions<infer UName, infer UCodec, infer UUniques, infer UParameters>;
                } ? PgResource<UName, UCodec, UUniques, UParameters, PgRegistry<TCodecs, TResourceOptions, TRelations>> : never;
            }>;
        };
    };
}
export type GetPgRegistryCodecs<TRegistry extends PgRegistry<any, any, any>> = TRegistry["pgCodecs"];
export type GetPgRegistrySources<TRegistry extends PgRegistry<any, any, any>> = TRegistry["pgResources"];
export type GetPgRegistryCodecRelations<TRegistry extends PgRegistry<any, any, any>, TCodec extends PgCodec<any, any, any, any, any, any, any>> = TRegistry["pgRelations"][TCodec["name"]];
export type GetPgCodecAttributes<TCodec extends PgCodec<any, any, any, any, any, any, any>> = TCodec extends PgCodec<any, infer UAttributes, any, any, any, any, any> ? UAttributes extends undefined ? never : UAttributes : PgCodecAttributes;
export type GetPgResourceRegistry<TResource extends PgResource<any, any, any, any, any>> = TResource["registry"];
export type GetPgResourceCodec<TResource extends PgResource<any, any, any, any, any>> = TResource["codec"];
export type GetPgResourceAttributes<TResource extends PgResource<any, any, any, any, any>> = GetPgCodecAttributes<TResource["codec"]>;
export type GetPgResourceRelations<TResource extends PgResource<any, any, any, any, any>> = TResource["registry"]["pgRelations"][TResource["codec"]["name"]];
export type GetPgResourceUniques<TResource extends PgResource<any, any, any, any, any>> = TResource["uniques"];
export {};
//# sourceMappingURL=interfaces.d.ts.map