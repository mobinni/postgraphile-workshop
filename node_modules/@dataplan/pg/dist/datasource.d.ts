import type { GrafastResultStreamList, GrafastValuesList, ObjectStep } from "grafast";
import { ExecutableStep } from "grafast";
import type { SQL } from "pg-sql2";
import type { PgCodecAttributes, PgCodecAttributeVia, PgCodecAttributeViaExplicit } from "./codecs.js";
import type { PgClientResult, PgExecutor, PgExecutorContextPlans, PgExecutorInput, PgExecutorMutationOptions, PgExecutorOptions } from "./executor.js";
import type { Expand, GetPgCodecAttributes, GetPgRegistryCodecRelations, GetPgRegistryCodecs, PgCodec, PgCodecRelationConfig, PgCodecWithAttributes, PgRefDefinition, PgRegistry, PgRegistryConfig, PlanByUniques } from "./interfaces.js";
import type { PgClassExpressionStep } from "./steps/pgClassExpression.js";
import type { PgSelectArgumentDigest, PgSelectArgumentSpec, PgSelectMode, PgSelectStep } from "./steps/pgSelect.js";
import type { PgSelectSinglePlanOptions, PgSelectSingleStep } from "./steps/pgSelectSingle.js";
export declare function EXPORTABLE<T, TScope extends any[]>(factory: (...args: TScope) => T, args: [...TScope]): T;
export interface PgResourceUniqueExtensions {
}
export interface PgResourceExtensions {
}
export interface PgResourceParameterExtensions {
    variant?: string;
}
export interface PgResourceParameter<TName extends string | null = string | null, TCodec extends PgCodec = PgCodec> {
    name: TName;
    codec: TCodec;
    required: boolean;
    notNull?: boolean;
    extensions?: PgResourceParameterExtensions;
}
export interface PgResourceUnique<TAttributes extends PgCodecAttributes = PgCodecAttributes> {
    attributes: ReadonlyArray<keyof TAttributes & string>;
    isPrimary?: boolean;
    description?: string;
    extensions?: PgResourceUniqueExtensions;
}
export interface PgCodecRefPathEntry {
    relationName: string;
}
export type PgCodecRefPath = PgCodecRefPathEntry[];
export interface PgCodecRefExtensions {
}
export interface PgCodecRef {
    definition: PgRefDefinition;
    paths: Array<PgCodecRefPath>;
    description?: string;
    extensions?: PgCodecRefExtensions;
}
export interface PgCodecRefs {
    [refName: string]: PgCodecRef;
}
export interface PgResourceOptions<TName extends string = string, TCodec extends PgCodec = PgCodec, TUniques extends ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>> = ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>>, TParameters extends readonly PgResourceParameter[] | undefined = readonly PgResourceParameter[] | undefined> {
    codec: TCodec;
    executor: PgExecutor;
    selectAuth?: ($step: PgSelectStep<PgResource<any, any, any, any, any>>) => void;
    name: TName;
    identifier?: string;
    from: TParameters extends readonly PgResourceParameter[] ? (...args: PgSelectArgumentDigest[]) => SQL : SQL;
    uniques?: TUniques;
    extensions?: PgResourceExtensions;
    parameters?: TParameters;
    description?: string;
    isUnique?: boolean;
    sqlPartitionByIndex?: SQL;
    isMutation?: boolean;
    isList?: boolean;
    isVirtual?: boolean;
}
export interface PgFunctionResourceOptions<TNewName extends string = string, TCodec extends PgCodec = PgCodec, TUniques extends ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>> = ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>>, TNewParameters extends readonly PgResourceParameter[] = readonly PgResourceParameter[]> {
    name: TNewName;
    identifier?: string;
    from: (...args: PgSelectArgumentDigest[]) => SQL;
    parameters: TNewParameters;
    returnsSetof: boolean;
    returnsArray: boolean;
    uniques?: TUniques;
    extensions?: PgResourceExtensions;
    isMutation?: boolean;
    selectAuth?: ($step: PgSelectStep<PgResource<any, any, any, any, any>>) => void;
    description?: string;
}
export declare class PgResource<TName extends string = string, TCodec extends PgCodec = PgCodec, TUniques extends ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>> = ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>>, TParameters extends readonly PgResourceParameter[] | undefined = readonly PgResourceParameter[] | undefined, TRegistry extends PgRegistry<any, any, any> = PgRegistry<any, any, any>> {
    readonly registry: TRegistry;
    readonly codec: TCodec;
    readonly executor: PgExecutor;
    readonly name: TName;
    readonly identifier: string;
    readonly from: SQL | ((...args: PgSelectArgumentDigest[]) => SQL);
    readonly uniques: TUniques;
    private selectAuth?;
    sqlPartitionByIndex: SQL | null;
    readonly parameters: TParameters;
    readonly description: string | undefined;
    readonly isUnique: boolean;
    readonly isMutation: boolean;
    readonly isList: boolean;
    readonly isVirtual: boolean;
    extensions: Partial<PgResourceExtensions> | undefined;
    static configFromCodec<TCodec extends PgCodec>(executor: PgExecutor, baseCodec: TCodec): PgResourceOptions<string, TCodec, ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>>, undefined>;
    constructor(registry: TRegistry, options: PgResourceOptions<TName, TCodec, TUniques, TParameters>);
    static alternativeResourceOptions<TCodec extends PgCodec, const TNewUniques extends ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>>, const TNewName extends string>(baseOptions: PgResourceOptions<any, TCodec, any, undefined>, overrideOptions: {
        name: TNewName;
        identifier?: string;
        from: SQL;
        uniques?: TNewUniques;
        extensions?: PgResourceExtensions;
    }): PgResourceOptions<TNewName, TCodec, TNewUniques, undefined>;
    static functionResourceOptions<TCodec extends PgCodec, const TNewParameters extends readonly PgResourceParameter[], const TNewUniques extends ReadonlyArray<PgResourceUnique<GetPgCodecAttributes<TCodec>>>, const TNewName extends string>(baseOptions: PgResourceOptions<any, TCodec, any, any>, overrideOptions: PgFunctionResourceOptions<TNewName, TCodec, TNewUniques, TNewParameters>): PgResourceOptions<TNewName, TCodec, TNewUniques, TNewParameters>;
    toString(): string;
    getRelations(): GetPgRegistryCodecRelations<TRegistry, TCodec>;
    getRelation<TRelationName extends keyof GetPgRegistryCodecRelations<TRegistry, TCodec>>(name: TRelationName): GetPgRegistryCodecRelations<TRegistry, TCodec>[TRelationName];
    resolveVia(via: PgCodecAttributeVia, attr: string): PgCodecAttributeViaExplicit;
    getReciprocal<TOtherCodec extends GetPgRegistryCodecs<TRegistry>, TOtherRelationName extends keyof GetPgRegistryCodecRelations<TRegistry, TOtherCodec>>(otherCodec: TOtherCodec, otherRelationName: TOtherRelationName): [
        relationName: keyof GetPgRegistryCodecRelations<TRegistry, TCodec>,
        relation: GetPgRegistryCodecRelations<TRegistry, TCodec>[keyof GetPgRegistryCodecRelations<TRegistry, TCodec>]
    ] | null;
    get(spec: PlanByUniques<GetPgCodecAttributes<TCodec>, TUniques>, _internalOptionsDoNotPass?: PgSelectSinglePlanOptions): GetPgCodecAttributes<TCodec> extends PgCodecAttributes ? PgSelectSingleStep<this> : PgClassExpressionStep<TCodec, this>;
    find(spec?: {
        [key in keyof GetPgCodecAttributes<TCodec>]?: ExecutableStep | string | number;
    }): PgSelectStep<this>;
    execute(args?: Array<PgSelectArgumentSpec>, mode?: PgSelectMode): ExecutableStep<unknown>;
    applyAuthorizationChecksToPlan($step: PgSelectStep<this>): void;
    context(): ObjectStep<PgExecutorContextPlans>;
    executeWithCache<TInput = any, TOutput = any>(values: GrafastValuesList<PgExecutorInput<TInput>>, options: PgExecutorOptions): Promise<{
        values: GrafastValuesList<ReadonlyArray<TOutput>>;
    }>;
    executeWithoutCache<TInput = any, TOutput = any>(values: GrafastValuesList<PgExecutorInput<TInput>>, options: PgExecutorOptions): Promise<{
        values: GrafastValuesList<ReadonlyArray<TOutput>>;
    }>;
    executeStream<TInput = any, TOutput = any>(values: GrafastValuesList<PgExecutorInput<TInput>>, options: PgExecutorOptions): Promise<{
        streams: GrafastResultStreamList<TOutput>;
    }>;
    executeMutation<TData>(options: PgExecutorMutationOptions): Promise<PgClientResult<TData>>;
    getNullCheckExpression(alias: SQL): SQL | null;
}
export interface PgRegistryBuilder<TCodecs extends {
    [name in string]: PgCodec<name, PgCodecAttributes | undefined, any, any, any, any, any>;
}, TResources extends {
    [name in string]: PgResourceOptions<name, PgCodec, ReadonlyArray<PgResourceUnique<PgCodecAttributes>>, readonly PgResourceParameter[] | undefined>;
}, TRelations extends {
    [codecName in keyof TCodecs]?: {
        [relationName in string]: PgCodecRelationConfig<PgCodec<string, PgCodecAttributes, any, any, undefined, any, undefined>, PgResourceOptions<any, PgCodecWithAttributes, any, any>>;
    };
}> {
    getRegistryConfig(): PgRegistryConfig<Expand<TCodecs>, Expand<TResources>, Expand<TRelations>>;
    addCodec<const TCodec extends PgCodec>(codec: TCodec): PgRegistryBuilder<TCodecs & {
        [name in TCodec["name"]]: TCodec;
    }, TResources, TRelations>;
    addResource<const TResource extends PgResourceOptions<any, any, any, any>>(resource: TResource): PgRegistryBuilder<TCodecs & {
        [name in TResource["codec"]["name"]]: TResource["codec"];
    }, TResources & {
        [name in TResource["name"]]: TResource;
    }, TRelations>;
    addRelation<TCodec extends PgCodec, const TCodecRelationName extends string, const TRemoteResource extends PgResourceOptions<any, any, any, any>, const TCodecRelation extends Omit<PgCodecRelationConfig<TCodec, TRemoteResource>, "localCodec" | "remoteResourceOptions">>(codec: TCodec, relationName: TCodecRelationName, remoteResource: TRemoteResource, relation: TCodecRelation): PgRegistryBuilder<TCodecs, TResources, TRelations & {
        [codecName in TCodec["name"]]: {
            [relationName in TCodecRelationName]: TCodecRelation & {
                localCodec: TCodec;
                remoteResourceOptions: TRemoteResource;
            };
        };
    }>;
    build(): PgRegistry<Expand<TCodecs>, Expand<TResources>, Expand<TRelations>>;
}
export declare function makeRegistry<TCodecs extends {
    [name in string]: PgCodec<name, PgCodecAttributes | undefined, any, any, any, any, any>;
}, TResourceOptions extends {
    [name in string]: PgResourceOptions<name, PgCodec, ReadonlyArray<PgResourceUnique<PgCodecAttributes<any>>>, readonly PgResourceParameter[] | undefined>;
}, TRelations extends {
    [codecName in keyof TCodecs]?: {
        [relationName in string]: PgCodecRelationConfig<PgCodec<string, PgCodecAttributes, any, any, undefined, any, undefined>, PgResourceOptions<any, PgCodecWithAttributes, any, any>>;
    };
}>(config: PgRegistryConfig<TCodecs, TResourceOptions, TRelations>): PgRegistry<TCodecs, TResourceOptions, TRelations>;
export declare function makeRegistryBuilder(): PgRegistryBuilder<{}, {}, {}>;
export declare function makePgResourceOptions<const TResourceOptions extends PgResourceOptions<any, any, any, any>>(options: TResourceOptions): TResourceOptions;
//# sourceMappingURL=datasource.d.ts.map