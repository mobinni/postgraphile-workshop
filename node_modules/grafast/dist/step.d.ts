import type { GraphQLObjectType } from "graphql";
import type { LayerPlan, LayerPlanReasonSubroutine } from "./engine/LayerPlan.js";
import type { OperationPlan } from "./engine/OperationPlan.js";
import type { ExecutionExtra, GrafastResultsList, GrafastResultStreamList, GrafastValuesList, PromiseOrDirect, StepOptimizeOptions, StepOptions } from "./interfaces.js";
import { $$subroutine } from "./interfaces.js";
import type { __ItemStep } from "./steps/index.js";
export declare const $$deepDepSkip: unique symbol;
export declare const $$noExec: unique symbol;
declare function reallyAssertFinalized(plan: BaseStep): void;
export declare const assertFinalized: typeof reallyAssertFinalized;
export declare abstract class BaseStep {
    readonly layerPlan: LayerPlan;
    readonly operationPlan: OperationPlan;
    [$$subroutine]: LayerPlan<LayerPlanReasonSubroutine> | null;
    isArgumentsFinalized: boolean;
    isFinalized: boolean;
    debug: boolean;
    hasSideEffects: boolean;
    constructor();
    toString(): string;
    toStringMeta(): string | null;
    finalize(): void;
    destroy(): void;
}
export declare class ExecutableStep<TData = any> extends BaseStep {
    static $$export: any;
    isSyncAndSafe: boolean;
    readonly dependencies: ReadonlyArray<ExecutableStep>;
    readonly dependents: ReadonlyArray<{
        step: ExecutableStep;
        dependencyIndex: number;
    }>;
    readonly id: number;
    isOptimized: boolean;
    allowMultipleOptimizations: boolean;
    _stepOptions: StepOptions;
    polymorphicPaths: ReadonlySet<string> | null;
    store: boolean;
    metaKey: number | string | symbol | undefined;
    optimizeMetaKey: number | string | symbol | undefined;
    constructor();
    protected withMyLayerPlan<T>(callback: () => T): T;
    protected getStep(id: number): ExecutableStep;
    getDep(depId: number): ExecutableStep;
    protected getDepDeep(depId: number): ExecutableStep;
    toString(): string;
    protected addDependency(step: ExecutableStep, skipDeduplication?: boolean): number;
    deduplicate?(_peers: readonly ExecutableStep[]): readonly ExecutableStep[];
    deduplicatedWith?(replacement: ExecutableStep): void;
    optimize?(_options: StepOptimizeOptions): ExecutableStep;
    finalize(): void;
    execute(count: number, values: ReadonlyArray<GrafastValuesList<any>>, extra: ExecutionExtra): PromiseOrDirect<GrafastResultsList<TData>>;
    destroy(): void;
}
export declare abstract class UnbatchedExecutableStep<TData = any> extends ExecutableStep<TData> {
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    finalize(): void;
    execute(count: number, values: ReadonlyArray<GrafastValuesList<any>>, extra: ExecutionExtra): PromiseOrDirect<GrafastResultsList<TData>>;
    abstract unbatchedExecute(extra: ExecutionExtra, ...tuple: any[]): PromiseOrDirect<TData>;
}
export declare function isExecutableStep<TData = any>(step: unknown): step is ExecutableStep<TData>;
export declare function assertExecutableStep<TData>(step: BaseStep): asserts step is ExecutableStep<TData>;
export declare function isUnbatchedExecutableStep<TData = any>(step: unknown): step is UnbatchedExecutableStep<TData>;
export type ObjectLikeStep<TData extends {
    [key: string]: ExecutableStep;
} = {
    [key: string]: ExecutableStep;
}> = ExecutableStep<{
    [key in keyof TData]: TData[key] extends ExecutableStep<infer U> ? U : never;
}> & {
    get<TKey extends keyof TData>(key: TKey): ExecutableStep<TData[TKey]>;
};
export declare function isObjectLikeStep<TData extends {
    [key: string]: ExecutableStep;
} = {
    [key: string]: ExecutableStep;
}>(plan: ExecutableStep): plan is ObjectLikeStep<TData>;
export type StreamableStep<TData> = ExecutableStep<ReadonlyArray<TData>> & {
    stream(count: number, values: ReadonlyArray<GrafastValuesList<any>>, extra: ExecutionExtra, streamOptions: {
        initialCount: number;
    }): PromiseOrDirect<GrafastResultStreamList<TData>>;
};
export declare function isStreamableStep<TData>(plan: ExecutableStep<ReadonlyArray<TData>>): plan is StreamableStep<TData>;
export type PolymorphicStep = ExecutableStep & {
    planForType(objectType: GraphQLObjectType): ExecutableStep;
};
export declare function isPolymorphicStep(s: ExecutableStep): s is PolymorphicStep;
export declare abstract class ModifierStep<TParentStep extends BaseStep = BaseStep> extends BaseStep {
    protected readonly $parent: TParentStep;
    static $$export: any;
    readonly id: string;
    constructor($parent: TParentStep);
    toString(): string;
    abstract apply(): void;
}
export declare function isModifierStep<TParentStep extends ExecutableStep | ModifierStep<any>>(plan: BaseStep): plan is ModifierStep<TParentStep>;
export declare function assertModifierStep<TParentStep extends ExecutableStep | ModifierStep<any>>(plan: BaseStep, pathDescription: string): asserts plan is ModifierStep<TParentStep>;
export interface ListCapableStep<TOutputData, TItemStep extends ExecutableStep<TOutputData> = ExecutableStep<TOutputData>> extends ExecutableStep<ReadonlyArray<any>> {
    listItem(itemPlan: __ItemStep<this>): TItemStep;
}
export declare function isListCapableStep<TData, TItemStep extends ExecutableStep<TData>>(plan: ExecutableStep<ReadonlyArray<TData>>): plan is ListCapableStep<TData, TItemStep>;
export declare function assertListCapableStep<TData, TItemStep extends ExecutableStep<TData>>(plan: ExecutableStep<ReadonlyArray<TData>>, pathDescription: string): asserts plan is ListCapableStep<TData, TItemStep>;
export {};
//# sourceMappingURL=step.d.ts.map