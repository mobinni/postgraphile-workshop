import type EventEmitter from "eventemitter3";
import type { PluginHook } from "graphile-config";
import type { ASTNode, ExecutionArgs, GraphQLArgument, GraphQLArgumentConfig, GraphQLField, GraphQLFieldConfig, GraphQLInputField, GraphQLInputFieldConfig, GraphQLInputObjectType, GraphQLInputType, GraphQLList, GraphQLNonNull, GraphQLOutputType, GraphQLScalarType, GraphQLSchema, GraphQLType, ValueNode, VariableNode } from "graphql";
import type { Bucket, RequestTools } from "./bucket.js";
import type { ExecutableStep, ListCapableStep, ModifierStep } from "./step.js";
import type { __InputDynamicScalarStep } from "./steps/__inputDynamicScalar.js";
import type { __InputListStep, __InputObjectStepWithDollars, __InputStaticLeafStep, __TrackedValueStep, __TrackedValueStepWithDollars, ConstantStep } from "./steps/index.js";
import type { GrafastInputObjectType, GrafastObjectType } from "./utils.js";
type PromiseOrValue<T> = T | Promise<T>;
export interface GrafastTimeouts {
    planning?: number;
    execution?: number;
}
export interface GrafastOptions {
    context?: Record<string, any> | (<TContext extends Record<string, any>>(ctx: Partial<Grafast.RequestContext>, currentContext?: Partial<TContext>) => PromiseOrValue<Partial<TContext>>);
    explain?: boolean | string[];
    timeouts?: GrafastTimeouts;
}
declare global {
    namespace Grafast {
        interface RequestContext {
        }
        interface Context {
        }
    }
    namespace GraphileConfig {
        interface Preset {
            grafast?: GrafastOptions;
        }
        interface GrafastHooks {
            args: PluginHook<(event: {
                args: ExecutionArgs;
                ctx: Grafast.RequestContext;
                resolvedPreset: GraphileConfig.ResolvedPreset;
            }) => PromiseOrValue<void>>;
        }
        interface Plugin {
            grafast?: {
                hooks?: GrafastHooks;
            };
        }
    }
}
export interface GrafastFieldExtensions {
    plan?: FieldPlanResolver<any, any, any>;
    subscribePlan?: FieldPlanResolver<any, any, any>;
}
export interface GrafastArgumentExtensions {
    inputPlan?: ArgumentInputPlanResolver;
    applyPlan?: ArgumentApplyPlanResolver;
    autoApplyAfterParentPlan?: boolean;
    autoApplyAfterParentSubscribePlan?: boolean;
}
export interface GrafastInputObjectTypeExtensions {
    inputPlan?: InputObjectTypeInputPlanResolver;
}
export interface GrafastInputFieldExtensions {
    inputPlan?: InputObjectFieldInputPlanResolver;
    applyPlan?: InputObjectFieldApplyPlanResolver;
    autoApplyAfterParentInputPlan?: boolean;
    autoApplyAfterParentApplyPlan?: boolean;
}
export interface GrafastObjectTypeExtensions {
    Step?: ((step: ExecutableStep) => asserts step is ExecutableStep) | {
        new (...args: any[]): ExecutableStep;
        displayName?: string;
    };
}
export interface GrafastEnumTypeExtensions {
}
export interface GrafastEnumValueExtensions {
    applyPlan?: EnumValueApplyPlanResolver<any>;
}
export interface GrafastScalarTypeExtensions {
    plan?: ScalarPlanResolver;
    inputPlan?: ScalarInputPlanResolver;
    idempotent?: boolean;
}
declare module "graphql" {
    interface GraphQLFieldExtensions<_TSource, _TContext, _TArgs = any> {
        grafast?: GrafastFieldExtensions;
    }
    interface GraphQLArgumentExtensions {
        grafast?: GrafastArgumentExtensions;
    }
    interface GraphQLInputObjectTypeExtensions {
        grafast?: GrafastInputObjectTypeExtensions;
    }
    interface GraphQLInputFieldExtensions {
        grafast?: GrafastInputFieldExtensions;
    }
    interface GraphQLObjectTypeExtensions<_TSource = any, _TContext = any> {
        grafast?: GrafastObjectTypeExtensions;
    }
    interface GraphQLEnumTypeExtensions {
        grafast?: GrafastEnumTypeExtensions;
    }
    interface GraphQLEnumValueExtensions {
        grafast?: GrafastEnumValueExtensions;
    }
    interface GraphQLScalarTypeExtensions {
        grafast?: GrafastScalarTypeExtensions;
    }
}
export declare const $$grafastContext: unique symbol;
export declare const $$planResults: unique symbol;
export declare const $$id: unique symbol;
export declare const $$verbatim: unique symbol;
export declare const $$bypassGraphQL: unique symbol;
export declare const $$data: unique symbol;
export declare const $$extensions: unique symbol;
export declare const $$concreteType: unique symbol;
export declare const $$idempotent: unique symbol;
export declare const $$eventEmitter: unique symbol;
export declare const $$streamMore: unique symbol;
export declare const $$proxy: unique symbol;
export declare const $$safeError: unique symbol;
export declare const $$subroutine: unique symbol;
export declare const $$timeout: unique symbol;
export declare const $$ts: unique symbol;
export interface PolymorphicData<TType extends string = string, TData = any> {
    [$$concreteType]: TType;
    [$$data]?: TData;
}
export interface IndexByListItemStepId {
    [listItemStepId: number]: number;
}
export type GrafastValuesList<T> = ReadonlyArray<T>;
export type PromiseOrDirect<T> = PromiseLike<T> | T;
export type GrafastResultsList<T> = ReadonlyArray<PromiseOrDirect<T>>;
export type GrafastResultStreamList<T> = ReadonlyArray<PromiseOrDirect<AsyncIterable<PromiseOrDirect<T>>> | PromiseLike<never>>;
export type BaseGraphQLRootValue = any;
export interface BaseGraphQLVariables {
    [key: string]: unknown;
}
export interface BaseGraphQLArguments {
    [key: string]: any;
}
export type BaseGraphQLInputObject = BaseGraphQLArguments;
export type TargetStepOrCallback = ExecutableStep | ModifierStep | ((indexOrFieldName: number | string) => TargetStepOrCallback);
export type FieldArgs = {
    get(path?: string | ReadonlyArray<string | number>): ExecutableStep;
    getRaw(path?: string | ReadonlyArray<string | number>): AnyInputStep;
    apply($target: ExecutableStep | ModifierStep | (() => ModifierStep), path?: string | ReadonlyArray<string | number>): void;
} & AnyInputStepDollars;
export type InputStep<TInputType extends GraphQLInputType = GraphQLInputType> = GraphQLInputType extends TInputType ? AnyInputStep : TInputType extends GraphQLNonNull<infer U> ? Exclude<InputStep<U & GraphQLInputType>, ConstantStep<undefined>> : TInputType extends GraphQLList<GraphQLInputType> ? __InputListStep<TInputType> | __TrackedValueStep<any, TInputType> | ConstantStep<undefined> : TInputType extends GraphQLInputObjectType ? __TrackedValueStepWithDollars<any, TInputType> | __InputObjectStepWithDollars<TInputType> | ConstantStep<undefined> : AnyInputStep;
export type AnyInputStep = __TrackedValueStepWithDollars<any, GraphQLInputType> | __InputListStep | __InputStaticLeafStep | __InputDynamicScalarStep | __InputObjectStepWithDollars<GraphQLInputObjectType> | ConstantStep<undefined>;
export type AnyInputStepWithDollars = AnyInputStep & AnyInputStepDollars;
export type AnyInputStepDollars = {
    [key in string as `$${key}`]: AnyInputStepWithDollars;
};
export interface FieldInfo {
    field: GraphQLField<any, any, any>;
    schema: GraphQLSchema;
}
export type FieldPlanResolver<_TArgs extends BaseGraphQLArguments, TParentStep extends ExecutableStep | null, TResultStep extends ExecutableStep> = ($parentPlan: TParentStep, args: FieldArgs, info: FieldInfo) => TResultStep | null;
export type InputObjectFieldInputPlanResolver<TResultStep extends ExecutableStep = ExecutableStep> = (input: FieldArgs, info: {
    schema: GraphQLSchema;
    entity: GraphQLInputField;
}) => TResultStep;
export type InputObjectFieldApplyPlanResolver<TFieldStep extends ExecutableStep | ModifierStep<any> = ExecutableStep | ModifierStep<any>, TResultStep extends ModifierStep<ExecutableStep | ModifierStep<any>> | null | void = ModifierStep<ExecutableStep | ModifierStep<any>> | null | void> = ($fieldPlan: TFieldStep, input: FieldArgs, info: {
    schema: GraphQLSchema;
    entity: GraphQLInputField;
}) => TResultStep;
export type InputObjectTypeInputPlanResolver = (input: FieldArgs, info: {
    schema: GraphQLSchema;
    type: GraphQLInputObjectType;
}) => ExecutableStep;
export type ArgumentInputPlanResolver<TParentStep extends ExecutableStep = ExecutableStep, TResultStep extends ExecutableStep = ExecutableStep> = ($parentPlan: TParentStep, input: FieldArgs, info: {
    schema: GraphQLSchema;
    entity: GraphQLArgument;
}) => TResultStep;
export type ArgumentApplyPlanResolver<TParentStep extends ExecutableStep = ExecutableStep, TFieldStep extends ExecutableStep | ModifierStep<any> = ExecutableStep | ModifierStep<any>, TResultStep extends ExecutableStep | ModifierStep<ExecutableStep | ModifierStep> | null | void = ExecutableStep | ModifierStep<ExecutableStep | ModifierStep> | null | void> = ($parentPlan: TParentStep, $fieldPlan: TFieldStep, input: FieldArgs, info: {
    schema: GraphQLSchema;
    entity: GraphQLArgument;
}) => TResultStep;
export type ScalarPlanResolver<TParentStep extends ExecutableStep = ExecutableStep, TResultStep extends ExecutableStep = ExecutableStep> = ($parentPlan: TParentStep, info: {
    schema: GraphQLSchema;
}) => TResultStep;
export type ScalarInputPlanResolver<TResultStep extends ExecutableStep = ExecutableStep> = ($inputValue: InputStep, info: {
    schema: GraphQLSchema;
    type: GraphQLScalarType;
}) => TResultStep;
export type EnumValueApplyPlanResolver<TParentStep extends ExecutableStep | ModifierStep = ExecutableStep | ModifierStep> = ($parent: TParentStep) => ModifierStep | void;
type OutputPlanForNamedType<TType extends GraphQLType> = TType extends GrafastObjectType<any, infer TStep, any> ? TStep : ExecutableStep;
export type OutputPlanForType<TType extends GraphQLOutputType> = TType extends GraphQLNonNull<GraphQLList<GraphQLNonNull<infer U>>> ? ListCapableStep<any, OutputPlanForNamedType<U>> | ExecutableStep : TType extends GraphQLNonNull<GraphQLList<infer U>> ? ListCapableStep<any, OutputPlanForNamedType<U>> | ExecutableStep : TType extends GraphQLList<GraphQLNonNull<infer U>> ? ListCapableStep<any, OutputPlanForNamedType<U>> | ExecutableStep : TType extends GraphQLList<infer U> ? ListCapableStep<any, OutputPlanForNamedType<U>> | ExecutableStep : TType extends GraphQLNonNull<infer U> ? OutputPlanForNamedType<U> : OutputPlanForNamedType<TType>;
type InputPlanForNamedType<TType extends GraphQLType> = TType extends GrafastInputObjectType<any, infer U, any> ? U : ModifierStep<any>;
type InputPlanForType<TType extends GraphQLInputType> = TType extends GraphQLNonNull<GraphQLList<GraphQLNonNull<infer U>>> ? InputPlanForNamedType<U> : TType extends GraphQLNonNull<GraphQLList<infer U>> ? InputPlanForNamedType<U> : TType extends GraphQLList<GraphQLNonNull<infer U>> ? InputPlanForNamedType<U> : TType extends GraphQLList<infer U> ? InputPlanForNamedType<U> : TType extends GraphQLNonNull<infer U> ? InputPlanForNamedType<U> : InputPlanForNamedType<TType>;
type InputTypeForNamedType<TType extends GraphQLType> = TType extends GraphQLScalarType<infer U> ? U : any;
type InputTypeFor<TType extends GraphQLInputType> = TType extends GraphQLNonNull<GraphQLList<GraphQLNonNull<infer U>>> ? InputTypeForNamedType<U> : TType extends GraphQLNonNull<GraphQLList<infer U>> ? InputTypeForNamedType<U> : TType extends GraphQLList<GraphQLNonNull<infer U>> ? InputTypeForNamedType<U> : TType extends GraphQLList<infer U> ? InputTypeForNamedType<U> : TType extends GraphQLNonNull<infer U> ? InputTypeForNamedType<U> : InputTypeForNamedType<TType>;
export type GrafastFieldConfig<TType extends GraphQLOutputType, TContext extends Grafast.Context, TParentStep extends ExecutableStep | null, TFieldStep extends ExecutableStep, TArgs extends BaseGraphQLArguments> = Omit<GraphQLFieldConfig<any, any>, "args" | "type"> & {
    type: TType;
    plan?: FieldPlanResolver<TArgs, TParentStep, TFieldStep>;
    subscribePlan?: FieldPlanResolver<TArgs, TParentStep, TFieldStep>;
    args?: GrafastFieldConfigArgumentMap<TType, TContext, TParentStep, TFieldStep>;
};
export type GrafastFieldConfigArgumentMap<_TType extends GraphQLOutputType, TContext extends Grafast.Context, TParentStep extends ExecutableStep | null, TFieldStep extends ExecutableStep> = {
    [argName: string]: GrafastArgumentConfig<any, TContext, TParentStep, TFieldStep, any, any>;
};
export type GrafastArgumentConfig<TInputType extends GraphQLInputType = GraphQLInputType, _TContext extends Grafast.Context = Grafast.Context, _TParentStep extends ExecutableStep | null = ExecutableStep | null, TFieldStep extends ExecutableStep = ExecutableStep, _TArgumentStep extends TFieldStep extends ExecutableStep ? ModifierStep<TFieldStep> | null : null = TFieldStep extends ExecutableStep ? ModifierStep<TFieldStep> | null : null, _TInput extends InputTypeFor<TInputType> = InputTypeFor<TInputType>> = Omit<GraphQLArgumentConfig, "type"> & {
    type: TInputType;
    inputPlan?: ArgumentInputPlanResolver<any>;
    applyPlan?: ArgumentApplyPlanResolver<any, any>;
    autoApplyAfterParentPlan?: boolean;
    autoApplyAfterParentSubscribePlan?: boolean;
};
export type GrafastInputFieldConfig<TInputType extends GraphQLInputType, _TContext extends Grafast.Context, _TParentStep extends ModifierStep<any>, _TResultStep extends InputPlanForType<TInputType>, _TInput extends InputTypeFor<TInputType>> = Omit<GraphQLInputFieldConfig, "type"> & {
    type: TInputType;
    inputPlan?: InputObjectFieldInputPlanResolver;
    applyPlan?: InputObjectFieldApplyPlanResolver<any>;
    autoApplyAfterParentInputPlan?: boolean;
    autoApplyAfterParentApplyPlan?: boolean;
};
export type TrackedArguments<TArgs extends BaseGraphQLArguments = BaseGraphQLArguments> = {
    get<TKey extends keyof TArgs>(key: TKey): AnyInputStep;
};
export interface StepStreamOptions {
    initialCount: number;
}
export interface StepOptions {
    stream: StepStreamOptions | null;
}
export interface StepOptimizeOptions {
    stream: StepStreamOptions | null;
    meta: Record<string, unknown> | undefined;
}
export type GrafastSubscriber<TTopics extends {
    [key: string]: any;
} = {
    [key: string]: any;
}> = {
    subscribe<TTopic extends keyof TTopics = keyof TTopics>(topic: TTopic): PromiseOrDirect<AsyncIterableIterator<TTopics[TTopic]>>;
};
export interface NodeIdCodec<T = any> {
    encode(value: T): string | null;
    decode(value: string): T;
}
export type NodeIdHandler<TCodecs extends {
    [key: string]: NodeIdCodec<any>;
} = {
    [key: string]: NodeIdCodec<any>;
}, TCodecName extends keyof TCodecs = keyof TCodecs, TNodeStep extends ExecutableStep = ExecutableStep, TSpec = any> = {
    typeName: string;
    codecName: TCodecName & string;
    match(specifier: TCodecs[TCodecName] extends NodeIdCodec<infer U> ? U : any): boolean;
    plan($thing: TNodeStep): ExecutableStep<TCodecs[TCodecName] extends NodeIdCodec<infer U> ? U : any>;
    getSpec(plan: ExecutableStep<TCodecs[TCodecName] extends NodeIdCodec<infer U> ? U : any>): TSpec;
    get(spec: TSpec): TNodeStep;
    deprecationReason?: string;
};
export type BaseEventMap = Record<string, any>;
export type EventMapKey<TEventMap extends BaseEventMap> = string & keyof TEventMap;
export type EventCallback<TPayload> = (params: TPayload) => void;
export interface TypedEventEmitter<TEventMap extends BaseEventMap> extends EventEmitter<any, any> {
    addListener<TEventName extends EventMapKey<TEventMap>>(eventName: TEventName, callback: EventCallback<TEventMap[TEventName]>): this;
    on<TEventName extends EventMapKey<TEventMap>>(eventName: TEventName, callback: EventCallback<TEventMap[TEventName]>): this;
    once<TEventName extends EventMapKey<TEventMap>>(eventName: TEventName, callback: EventCallback<TEventMap[TEventName]>): this;
    removeListener<TEventName extends EventMapKey<TEventMap>>(eventName: TEventName, callback: EventCallback<TEventMap[TEventName]>): this;
    off<TEventName extends EventMapKey<TEventMap>>(eventName: TEventName, callback: EventCallback<TEventMap[TEventName]>): this;
    emit<TEventName extends EventMapKey<TEventMap>>(eventName: TEventName, params: TEventMap[TEventName]): boolean;
}
export type ExecutionEventMap = {
    explainOperation: {
        operation: Record<string, any> & {
            type: string;
            title: string;
        };
    };
};
export type ExecutionEventEmitter = TypedEventEmitter<ExecutionEventMap>;
export interface ExecutionExtra {
    stopTime: number | null;
    meta: Record<string, unknown> | undefined;
    eventEmitter: ExecutionEventEmitter | undefined;
    _bucket: Bucket;
    _requestContext: RequestTools;
}
export interface LocationDetails {
    node: ASTNode | readonly ASTNode[];
    parentTypeName: string | null;
    fieldName: string | null;
}
export type JSONValue = boolean | number | string | null | JSONObject | JSONArray;
export interface JSONObject {
    [key: string]: JSONValue;
}
export interface JSONArray extends Array<JSONValue> {
}
export type UnwrapPlanTuple<TIn extends readonly ExecutableStep[]> = {
    [Index in keyof TIn]: TIn[Index] extends ExecutableStep<infer U> ? U : never;
} & {
    length: number;
};
export type NotVariableValueNode = Exclude<ValueNode, VariableNode>;
export {};
//# sourceMappingURL=interfaces.d.ts.map