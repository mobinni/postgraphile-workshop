import type { ExecutionExtra, GrafastResultsList, InputStep } from "../interfaces.js";
import type { ExecutableStep } from "../step.js";
import { UnbatchedExecutableStep } from "../step.js";
type ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any ? R : never[];
export interface PageInfoCapableStep extends ExecutableStep {
    hasNextPage(): ExecutableStep<boolean>;
    hasPreviousPage(): ExecutableStep<boolean>;
    startCursor(): ExecutableStep<string | null>;
    endCursor(): ExecutableStep<string | null>;
}
export interface ConnectionCapableStep<TItemStep extends ExecutableStep, TCursorStep extends ExecutableStep> extends ExecutableStep<ReadonlyArray<TItemStep extends ExecutableStep<infer U> ? U : any>> {
    connectionClone($connection: ConnectionStep<TItemStep, TCursorStep, any, any>, ...args: any[]): ConnectionCapableStep<TItemStep, TCursorStep>;
    pageInfo($connection: ConnectionStep<TItemStep, TCursorStep, ConnectionCapableStep<TItemStep, TCursorStep>, any>): PageInfoCapableStep;
    setFirst($plan: InputStep): void;
    setLast($plan: InputStep): void;
    setOffset($plan: InputStep): void;
    parseCursor($plan: InputStep): TCursorStep | null | undefined;
    setBefore($plan: TCursorStep): void;
    setAfter($plan: TCursorStep): void;
}
export declare class ConnectionStep<TItemStep extends ExecutableStep, TCursorStep extends ExecutableStep, TStep extends ConnectionCapableStep<TItemStep, TCursorStep>, TNodeStep extends ExecutableStep = ExecutableStep> extends UnbatchedExecutableStep<unknown> {
    readonly itemPlan?: (($item: TItemStep) => TNodeStep) | undefined;
    readonly cursorPlan?: (($item: TItemStep) => ExecutableStep<string | null> | undefined) | undefined;
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    private subplanId;
    private _firstDepId;
    private _lastDepId;
    private _offsetDepId;
    private _beforeDepId;
    private _afterDepId;
    constructor(subplan: TStep, itemPlan?: (($item: TItemStep) => TNodeStep) | undefined, cursorPlan?: (($item: TItemStep) => ExecutableStep<string | null> | undefined) | undefined);
    toStringMeta(): string;
    getFirst(): InputStep | null;
    setFirst($firstPlan: InputStep): void;
    getLast(): InputStep | null;
    setLast($lastPlan: InputStep): void;
    getOffset(): InputStep | null;
    setOffset($offsetPlan: InputStep): void;
    getBefore(): TCursorStep | null;
    setBefore($beforePlan: InputStep): void;
    getAfter(): TCursorStep | null;
    setAfter($afterPlan: InputStep): void;
    getSubplan(): TStep;
    cloneSubplanWithoutPagination(...args: ParametersExceptFirst<TStep["connectionClone"]>): TStep;
    cloneSubplanWithPagination(...args: ParametersExceptFirst<TStep["connectionClone"]> | []): TStep;
    addValidation(callback: () => ExecutableStep): void;
    edges(): ExecutableStep;
    nodes(): TStep | import("./listTransform.js").__ListTransformStep<any, any, any, any>;
    wrapEdge($edge: TItemStep): EdgeStep<TItemStep, TCursorStep, TStep, TNodeStep>;
    pageInfo(): PageInfoCapableStep;
    execute(count: number): GrafastResultsList<Record<string, never>>;
    unbatchedExecute(): any;
}
export interface EdgeCapableStep<TNodeStep extends ExecutableStep> extends ExecutableStep {
    node(): TNodeStep;
    cursor(): ExecutableStep<string | null>;
}
export declare class EdgeStep<TItemStep extends ExecutableStep, TCursorStep extends ExecutableStep, TStep extends ConnectionCapableStep<TItemStep, TCursorStep>, TNodeStep extends ExecutableStep = ExecutableStep> extends UnbatchedExecutableStep implements EdgeCapableStep<TNodeStep> {
    private skipCursor;
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    private connectionDepId;
    private readonly cursorDepId;
    private needCursor;
    constructor($connection: ConnectionStep<TItemStep, TCursorStep, TStep, TNodeStep>, $item: TItemStep, skipCursor?: boolean);
    private getConnectionStep;
    private getItemStep;
    node(): TNodeStep;
    cursor(): ExecutableStep<string | null>;
    optimize(): EdgeStep<TItemStep, TCursorStep, TStep, TNodeStep>;
    deduplicate(_peers: EdgeStep<any, any, any, any>[]): EdgeStep<TItemStep, TCursorStep, TStep, TNodeStep>[];
    deduplicatedWith(replacement: EdgeStep<any, any, any, any>): void;
    unbatchedExecute(_extra: ExecutionExtra, record: any, cursor: any): any;
}
export declare function connection<TItemStep extends ExecutableStep, TCursorStep extends ExecutableStep, TStep extends ConnectionCapableStep<TItemStep, TCursorStep>, TNodeStep extends ExecutableStep = ExecutableStep>(step: TStep, itemPlan?: ($item: TItemStep) => TNodeStep, cursorPlan?: ($item: TItemStep) => ExecutableStep<string | null>): ConnectionStep<TItemStep, TCursorStep, TStep, TNodeStep>;
export {};
//# sourceMappingURL=connection.d.ts.map