import type { ExecutionExtra, PromiseOrDirect, UnwrapPlanTuple } from "../interfaces.js";
import type { ExecutableStep } from "../step.js";
import { UnbatchedExecutableStep } from "../step.js";
export declare class LambdaStep<TIn, TOut> extends UnbatchedExecutableStep<TOut> {
    private fn;
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    allowMultipleOptimizations: boolean;
    private planDep;
    constructor($plan: ExecutableStep<TIn> | null | undefined, fn: (value: TIn) => PromiseOrDirect<TOut>);
    toStringMeta(): any;
    deduplicate(peers: LambdaStep<any, any>[]): LambdaStep<TIn, TOut>[];
    unbatchedExecute(_extra: ExecutionExtra, value: TIn): PromiseOrDirect<TOut>;
}
declare function lambda<const TIn extends readonly ExecutableStep[], TOut>(plans: TIn, fn: (value: UnwrapPlanTuple<TIn>) => PromiseOrDirect<TOut>, isSyncAndSafe?: boolean): LambdaStep<UnwrapPlanTuple<TIn>, TOut>;
declare function lambda<const TIn, TOut>($plan: ExecutableStep<TIn> | null | undefined, fn: (value: TIn) => PromiseOrDirect<TOut>, isSyncAndSafe?: boolean): LambdaStep<TIn, TOut>;
export { lambda };
//# sourceMappingURL=lambda.d.ts.map