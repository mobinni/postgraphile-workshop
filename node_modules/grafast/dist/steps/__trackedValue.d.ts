import type { GraphQLInputObjectType, GraphQLInputType, VariableDefinitionNode } from "graphql";
import { GraphQLList, GraphQLNonNull } from "graphql";
import type { Constraint } from "../constraints.js";
import type { ExecutionExtra, GrafastResultsList, GrafastValuesList } from "../interfaces.js";
import { UnbatchedExecutableStep } from "../step.js";
import type { __ValueStep } from "./__value.js";
import type { AccessStep } from "./access.js";
export declare class __TrackedValueStep<TData = any, TInputType extends GraphQLInputType | ReadonlyArray<VariableDefinitionNode> | undefined = undefined> extends UnbatchedExecutableStep<TData> {
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    private readonly value;
    private readonly constraints;
    private readonly path;
    static withGraphQLType<TInputType extends GraphQLInputType, TData = any>(value: TData | undefined, valuePlan: __ValueStep<TData> | AccessStep<TData>, constraints: Constraint[], path: (string | number)[] | undefined, graphqlType: TInputType): __TrackedValueStepWithDollars<TData, TInputType>;
    private nullableGraphQLType;
    private variableDefinitions;
    constructor(value: TData | undefined, valuePlan: __ValueStep<TData> | AccessStep<TData>, constraints: Constraint[], path?: Array<string | number>, graphqlTypeOrVariableDefinitions?: TInputType);
    execute(_count: number, values: [GrafastValuesList<TData>]): GrafastResultsList<TData>;
    unbatchedExecute(_extra: ExecutionExtra, v: TData): TData;
    private getValuePlan;
    get<TAttribute extends keyof TData & string>(attrName: TAttribute): __TrackedValueStepWithDollars<TData[TAttribute], TInputType extends GraphQLInputObjectType ? ReturnType<TInputType["getFields"]>[TAttribute]["type"] : undefined>;
    at<TIndex extends keyof TData & number>(index: TIndex): __TrackedValueStepWithDollars<TData[TIndex], TInputType extends GraphQLList<infer U> ? U & GraphQLInputType : TInputType extends GraphQLNonNull<GraphQLList<infer U>> ? U & GraphQLInputType : undefined>;
    eval(): TData | undefined;
    evalIs(expectedValue: unknown): boolean;
    evalIsEmpty(): boolean;
    evalHas(key: string): boolean;
    evalLength(): number | null;
    optimize(): import("../step.js").ExecutableStep<any>;
}
export type __TrackedValueStepWithDollars<TData = any, TInputType extends GraphQLInputType | undefined = undefined> = __TrackedValueStep<TData, TInputType> & (TInputType extends GraphQLInputObjectType ? {
    [key in keyof ReturnType<TInputType["getFields"]> & string as `$${key}`]: __TrackedValueStepWithDollars<TData extends {
        [k in key]: infer U;
    } ? U : any, ReturnType<TInputType["getFields"]>[key]["type"]>;
} : Record<string, never>);
//# sourceMappingURL=__trackedValue.d.ts.map