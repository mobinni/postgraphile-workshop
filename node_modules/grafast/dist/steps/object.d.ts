import type { ExecutionExtra, StepOptimizeOptions } from "../interfaces.js";
import type { ExecutableStep } from "../step.js";
import { UnbatchedExecutableStep } from "../step.js";
import { ConstantStep } from "./constant.js";
import type { SetterCapableStep } from "./setter.js";
type DataFromStep<TStep extends ExecutableStep> = TStep extends ExecutableStep<infer TData> ? TData : never;
type DataFromPlans<TPlans extends {
    [key: string]: ExecutableStep;
}> = {
    [key in keyof TPlans]: DataFromStep<TPlans[key]>;
};
type Results<TPlans extends {
    [key: string]: ExecutableStep;
}> = Array<[
    Array<DataFromPlans<TPlans>[keyof TPlans]>,
    DataFromPlans<TPlans>
]>;
export interface ObjectPlanMeta<TPlans extends {
    [key: string]: ExecutableStep;
}> {
    results: Results<TPlans>;
}
export declare class ObjectStep<TPlans extends {
    [key: string]: ExecutableStep;
} = {
    [key: string]: ExecutableStep;
}> extends UnbatchedExecutableStep<DataFromPlans<TPlans>> implements SetterCapableStep<TPlans> {
    static $$export: {
        moduleName: string;
        exportName: string;
    };
    isSyncAndSafe: boolean;
    allowMultipleOptimizations: boolean;
    private keys;
    optimizeMetaKey: string;
    constructor(obj: TPlans);
    set<TKey extends keyof TPlans>(key: TKey, plan: TPlans[TKey]): void;
    getStepForKey<TKey extends keyof TPlans>(key: TKey, allowMissing?: boolean): TKey extends keyof TPlans ? TPlans[TKey] : null;
    toStringMeta(): string;
    tupleToObjectJIT(callback: (fn: (extra: ExecutionExtra, ...tuple: Array<DataFromPlans<TPlans>[keyof TPlans]>) => DataFromPlans<TPlans>) => void): void;
    finalize(): void;
    execute(count: number, values: Array<Array<DataFromPlans<TPlans>[keyof TPlans]>>, extra: ExecutionExtra): Array<DataFromPlans<TPlans>>;
    unbatchedExecute(_extra: ExecutionExtra, ..._values: any[]): any;
    deduplicate(peers: ObjectStep<any>[]): ObjectStep<TPlans>[];
    optimize(opts: StepOptimizeOptions): this | ConstantStep<any>;
    get<TKey extends keyof TPlans>(key: TKey): TPlans[TKey];
}
export declare function object<TPlans extends {
    [key: string]: ExecutableStep;
}>(obj: TPlans): ObjectStep<TPlans>;
export {};
//# sourceMappingURL=object.d.ts.map