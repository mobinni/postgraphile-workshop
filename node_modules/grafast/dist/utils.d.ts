import type { ConstValueNode, FieldNode, GraphQLEnumValueConfig, GraphQLFieldConfig, GraphQLInputFieldConfig, GraphQLInputObjectTypeConfig, GraphQLInputType, GraphQLNamedType, GraphQLObjectTypeConfig, GraphQLOutputType, GraphQLSchema } from "graphql";
import * as graphql from "graphql";
import type { Deferred } from "./deferred.js";
import type { OperationPlan } from "./engine/OperationPlan.js";
import type { BaseGraphQLArguments, GrafastFieldConfig, GrafastInputFieldConfig, InputStep, OutputPlanForType } from "./interfaces.js";
import type { ExecutableStep, ModifierStep } from "./step.js";
export declare const ROOT_VALUE_OBJECT: any;
export declare function assertNullPrototype(object: Record<string, unknown>, description: string): void;
export declare function defaultValueToValueNode(type: GraphQLInputType, defaultValue: unknown): ConstValueNode | undefined;
export declare function isPromise<T>(t: T | Promise<T>): t is Promise<T>;
export declare function isPromiseLike<T>(t: T | Promise<T> | PromiseLike<T>): t is PromiseLike<T>;
export declare function isDeferred<T>(t: T | Promise<T> | Deferred<T>): t is Deferred<T>;
export declare function arraysMatch<T>(array1: ReadonlyArray<T>, array2: ReadonlyArray<T>, comparator?: (val1: T, val2: T) => boolean): boolean;
export type ObjectTypeFields<TContext extends Grafast.Context, TParentStep extends ExecutableStep> = {
    [key: string]: GrafastFieldConfig<GraphQLOutputType, TContext, TParentStep, any, any>;
};
export type ObjectTypeSpec<TContext extends Grafast.Context, TParentStep extends ExecutableStep, TFields extends ObjectTypeFields<TContext, TParentStep>> = Omit<GraphQLObjectTypeConfig<any, TContext>, "fields"> & {
    fields: TFields | (() => TFields);
};
export declare function objectSpec<TContext extends Grafast.Context, TParentStep extends ExecutableStep, TFields extends ObjectTypeFields<TContext, TParentStep>>(spec: ObjectTypeSpec<TContext, TParentStep, TFields>, Step: ((step: ExecutableStep) => asserts step is ExecutableStep) | {
    new (...args: any[]): TParentStep;
} | null): GraphQLObjectTypeConfig<any, TContext>;
export type GrafastObjectType<TContext extends Grafast.Context, TParentStep extends ExecutableStep, TFields extends ObjectTypeFields<TContext, TParentStep>> = graphql.GraphQLObjectType<TParentStep extends ExecutableStep<infer U> ? U : never, TContext> & {
    TParentStep: TParentStep;
    TFields: TFields;
};
export declare function newObjectTypeBuilder<TContext extends Grafast.Context, TParentStep extends ExecutableStep>(Step: {
    new (...args: any[]): TParentStep;
}): <TFields extends ObjectTypeFields<TContext, TParentStep>>(spec: ObjectTypeSpec<TContext, TParentStep, TFields>) => GrafastObjectType<TContext, TParentStep, TFields>;
export declare function objectFieldSpec<TContext extends Grafast.Context, TSource extends ExecutableStep, TResult extends ExecutableStep = ExecutableStep, TArgs extends BaseGraphQLArguments = BaseGraphQLArguments>(grafastSpec: GrafastFieldConfig<GraphQLOutputType, TContext, TSource, TResult, TArgs>, path: string): GraphQLFieldConfig<any, TContext, TArgs>;
export declare function newGrafastFieldConfigBuilder<TContext extends Grafast.Context, TParentStep extends ExecutableStep>(): <TType extends GraphQLOutputType, TFieldStep extends OutputPlanForType<TType>, TArgs extends BaseGraphQLArguments>(config: GrafastFieldConfig<TType, TContext, TParentStep, TFieldStep, TArgs>) => typeof config;
export type GrafastInputFieldConfigMap<TContext extends Grafast.Context, TParentStep extends ModifierStep<any>> = {
    [key: string]: GrafastInputFieldConfig<GraphQLInputType, TContext, TParentStep, any, any>;
};
export type InputObjectTypeSpec<TContext extends Grafast.Context, TParentStep extends ModifierStep<any>, TFields extends GrafastInputFieldConfigMap<TContext, TParentStep>> = Omit<GraphQLInputObjectTypeConfig, "fields"> & {
    fields: TFields | (() => TFields);
};
export type GrafastInputObjectType<TContext extends Grafast.Context, TParentStep extends ModifierStep<any>, TFields extends GrafastInputFieldConfigMap<TContext, TParentStep>> = graphql.GraphQLInputObjectType & {
    TContext: TContext;
    TParentStep: TParentStep;
    TFields: TFields;
};
export declare function newInputObjectTypeBuilder<TContext extends Grafast.Context, TParentStep extends ModifierStep<any>>(): <TFields extends GrafastInputFieldConfigMap<TContext, TParentStep>>(spec: InputObjectTypeSpec<TContext, TParentStep, TFields>) => GrafastInputObjectType<TContext, TParentStep, TFields>;
export declare function inputObjectFieldSpec<TContext extends Grafast.Context, TParent extends ModifierStep<any>, TResult extends ModifierStep<TParent> = ModifierStep<TParent>, TInput extends InputStep = InputStep>(grafastSpec: GrafastInputFieldConfig<GraphQLInputType, TContext, TParent, TResult, TInput>, path: string): GraphQLInputFieldConfig;
declare module "graphql" {
    interface GraphQLEnumType {
        [$$valueConfigByValue]?: Record<string, GraphQLEnumValueConfig>;
    }
}
declare const $$valueConfigByValue: unique symbol;
export declare function getEnumValueConfig(enumType: graphql.GraphQLEnumType, outputValue: string): GraphQLEnumValueConfig | undefined;
export declare const sharedNull: any;
export declare function stack(message: string, length?: number): void;
export declare function arrayOfLength(length: number, fill?: any): any[];
export declare function arrayOfLengthCb(length: number, fill: () => any): any[];
export declare function findVariableNamesUsed(operationPlan: OperationPlan, field: FieldNode): string[];
export declare function isTypePlanned(schema: GraphQLSchema, namedType: GraphQLNamedType): boolean;
export declare function stepADependsOnStepB(stepA: ExecutableStep, stepB: ExecutableStep): boolean;
export declare function stepAMayDependOnStepB($a: ExecutableStep, $b: ExecutableStep): boolean;
export declare function stepsAreInSamePhase(ancestor: ExecutableStep, descendent: ExecutableStep): boolean;
export declare const canonicalJSONStringify: (o: object) => string;
export declare function assertNotAsync(fn: any, name: string): void;
export {};
//# sourceMappingURL=utils.d.ts.map