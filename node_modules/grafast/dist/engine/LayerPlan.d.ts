import type { Bucket } from "../bucket.js";
import type { ExecutableStep, ModifierStep, UnbatchedExecutableStep } from "../step";
import type { OperationPlan } from "./OperationPlan";
export interface LayerPlanReasonRoot {
    type: "root";
}
export interface LayerPlanReasonNullableField {
    type: "nullableBoundary";
    parentStep: ExecutableStep;
}
export interface LayerPlanReasonListItem {
    type: "listItem";
    parentStep: ExecutableStep;
    stream?: {
        initialCount: number;
        label?: string;
    };
}
export interface LayerPlanReasonSubscription {
    type: "subscription";
}
export interface LayerPlanReasonMutationField {
    type: "mutationField";
    mutationIndex: number;
}
export interface LayerPlanReasonDefer {
    type: "defer";
    label?: string;
}
export interface LayerPlanReasonPolymorphic {
    type: "polymorphic";
    typeNames: string[];
    parentStep: ExecutableStep;
    polymorphicPaths: Set<string>;
}
export interface LayerPlanReasonSubroutine {
    type: "subroutine";
    parentStep: ExecutableStep;
}
export declare function isBranchingLayerPlan(layerPlan: LayerPlan<any>): boolean;
export declare function isDeferredLayerPlan(layerPlan: LayerPlan<any>): boolean;
export declare function isPolymorphicLayerPlan(layerPlan: LayerPlan<any>): boolean;
export type LayerPlanReason = LayerPlanReasonRoot | LayerPlanReasonNullableField | LayerPlanReasonListItem | LayerPlanReasonSubscription | LayerPlanReasonMutationField | LayerPlanReasonDefer | LayerPlanReasonPolymorphic | LayerPlanReasonSubroutine;
export type HasParent<A extends LayerPlanReason> = A extends any ? A extends {
    parentStep: ExecutableStep;
} ? A : never : never;
export type LayerPlanReasonsWithParentStep = HasParent<LayerPlanReason>;
export interface LayerPlanPhase {
    checkTimeout: boolean;
    normalSteps: Array<{
        step: ExecutableStep;
    }> | undefined;
    unbatchedSyncAndSafeSteps: Array<{
        step: UnbatchedExecutableStep;
        scratchpad: any;
    }> | undefined;
    _allSteps: ExecutableStep[];
}
export declare class LayerPlan<TReason extends LayerPlanReason = LayerPlanReason> {
    readonly operationPlan: OperationPlan;
    parentLayerPlan: LayerPlan | null;
    readonly reason: TReason;
    id: number;
    readonly rootStep: ExecutableStep | null;
    copyStepIds: number[];
    children: LayerPlan[];
    steps: ExecutableStep[];
    pendingSteps: ExecutableStep[];
    phases: Array<LayerPlanPhase>;
    ancestry: LayerPlan[];
    depth: number;
    deferBoundaryDepth: number;
    stepsByConstructor: Map<Function, Set<ExecutableStep>>;
    constructor(operationPlan: OperationPlan, parentLayerPlan: LayerPlan | null, reason: TReason);
    toString(): string;
    print(depth?: number): string;
    setRootStep($root: ExecutableStep): void;
    getStep(id: number, requestingStep: ExecutableStep): ExecutableStep;
    _addStep(step: ExecutableStep): number;
    _addModifierStep(step: ModifierStep<any>): string;
    finalize(): void;
    newBucket(parentBucket: Bucket): Bucket | null;
}
//# sourceMappingURL=LayerPlan.d.ts.map