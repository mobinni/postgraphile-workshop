import type { FragmentDefinitionNode, GraphQLFieldMap, GraphQLObjectType, GraphQLSchema, GraphQLUnionType, OperationDefinitionNode } from "graphql";
import type { Constraint } from "../constraints.js";
import type { SelectionSetDigest } from "../graphqlCollectFields.js";
import type { ModifierStep } from "../index.js";
import { __TrackedValueStep, __ValueStep, ExecutableStep } from "../index.js";
import { $$timeout, $$ts } from "../interfaces.js";
import type { PrintPlanGraphOptions } from "../mermaid.js";
import type { LayerPlanReasonSubroutine } from "./LayerPlan.js";
import { LayerPlan } from "./LayerPlan.js";
import { OutputPlan } from "./OutputPlan.js";
import { StepTracker } from "./StepTracker.js";
export declare const POLYMORPHIC_ROOT_PATH: null;
export declare const POLYMORPHIC_ROOT_PATHS: ReadonlySet<string> | null;
export type OperationPlanPhase = "init" | "plan" | "validate" | "optimize" | "finalize" | "ready";
export interface MetaByMetaKey {
    [metaKey: string | number | symbol]: Record<string, any>;
}
export declare class OperationPlan {
    readonly schema: GraphQLSchema;
    readonly operation: OperationDefinitionNode;
    readonly fragments: {
        [fragmentName: string]: FragmentDefinitionNode;
    };
    readonly variableValues: {
        [key: string]: any;
    };
    readonly context: {
        [key: string]: any;
    };
    readonly rootValue: any;
    private readonly planningTimeout;
    readonly [$$timeout]: undefined;
    readonly [$$ts]: undefined;
    readonly queryType: GraphQLObjectType;
    readonly mutationType: GraphQLObjectType | null;
    readonly subscriptionType: GraphQLObjectType | null;
    readonly unionsContainingObjectType: {
        [objectTypeName: string]: ReadonlyArray<GraphQLUnionType>;
    };
    private operationType;
    phase: OperationPlanPhase;
    loc: string[] | null;
    rootLayerPlan: LayerPlan;
    rootOutputPlan: OutputPlan;
    private modifierStepCount;
    private modifierDepthCount;
    private modifierSteps;
    readonly stepTracker: StepTracker;
    private maxDeduplicatedStepId;
    private maxValidatedStepId;
    readonly variableValuesConstraints: Constraint[];
    readonly variableValuesStep: __ValueStep<{
        [key: string]: any;
    }>;
    readonly trackedVariableValuesStep: __TrackedValueStep<{
        [key: string]: any;
    }>;
    readonly contextConstraints: Constraint[];
    readonly contextStep: __ValueStep<Grafast.Context>;
    readonly trackedContextStep: __TrackedValueStep<{
        [key: string]: any;
    }>;
    readonly rootValueConstraints: Constraint[];
    readonly rootValueStep: __ValueStep<any>;
    readonly trackedRootValueStep: __TrackedValueStep<any>;
    makeMetaByMetaKey: () => MetaByMetaKey;
    readonly itemStepIdByListStepId: {
        [listStepId: number]: number | undefined;
    };
    pure: boolean;
    private startTime;
    private previousLap;
    private laps;
    private optimizeMeta;
    private scalarPlanInfo;
    constructor(schema: GraphQLSchema, operation: OperationDefinitionNode, fragments: {
        [fragmentName: string]: FragmentDefinitionNode;
    }, variableValues: {
        [key: string]: any;
    }, context: {
        [key: string]: any;
    }, rootValue: any, planningTimeout: number | null);
    private lap;
    private checkTimeout;
    addLayerPlan(layerPlan: LayerPlan): number;
    _addStep(plan: ExecutableStep): number;
    _addModifierStep(step: ModifierStep<any>): string;
    getStep: (id: number, requestingStep: ExecutableStep) => ExecutableStep;
    dangerouslyGetStep(id: number): ExecutableStep;
    private planOperation;
    private planQuery;
    private planMutation;
    private planSubscription;
    private itemStepForListStep;
    processGroupedFieldSet(outputPlan: OutputPlan, path: readonly string[], polymorphicPath: string | null, polymorphicPaths: ReadonlySet<string> | null, parentStep: ExecutableStep, objectType: GraphQLObjectType, objectTypeFields: GraphQLFieldMap<any, any>, isMutation: boolean, groupedFieldSet: SelectionSetDigest): void;
    private planSelectionSet;
    private planIntoOutputPlan;
    private polymorphicLayerPlanByPathByLayerPlan;
    private getPolymorphicLayerPlan;
    private planField;
    private getTrackedArguments;
    withModifiers<T>(cb: () => T): T;
    private track;
    private validateSteps;
    private replaceStep;
    private processStep;
    processSteps(actionDescription: string, order: "dependents-first" | "dependencies-first", isReadonly: boolean, callback: (plan: ExecutableStep) => ExecutableStep): void;
    private getPeers;
    private isImmoveable;
    private hoistStep;
    private pushDown;
    private _deduplicateInnerLogic;
    private deduplicateStep;
    private deduplicateStepsProcess;
    private deduplicateSteps;
    private hoistAndDeduplicate;
    private hoistSteps;
    private pushDownSteps;
    private getStepOptionsForStep;
    private optimizeStep;
    private optimizeSteps;
    private finalizeSteps;
    private finalizeLayerPlans;
    private optimizeOutputPlans;
    private finalizeOutputPlans;
    private walkOutputPlans;
    printPlanGraph(options?: PrintPlanGraphOptions): string;
    finishSubroutine(subroutineStep: ExecutableStep, layerPlan: LayerPlan<LayerPlanReasonSubroutine>): void;
    deleteLayerPlan(layerPlan: LayerPlan): void;
    getStepsByMetaKey(metaKey: string | number | symbol): ExecutableStep[];
    getStepsByStepClass<TClass extends ExecutableStep>(klass: {
        new (...args: any[]): TClass;
    }): TClass[];
}
//# sourceMappingURL=OperationPlan.d.ts.map