"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.postgraphile = exports.watchSchema = exports.makeSchema = void 0;
// Copy the types through for our dependents
require("graphile-build-pg");
const grafast_1 = require("grafast");
const graphile_build_1 = require("graphile-build");
Object.defineProperty(exports, "makeSchema", { enumerable: true, get: function () { return graphile_build_1.makeSchema; } });
Object.defineProperty(exports, "watchSchema", { enumerable: true, get: function () { return graphile_build_1.watchSchema; } });
const graphile_config_1 = require("graphile-config");
function noop() { }
function postgraphile(preset) {
    const resolvedPreset = (0, graphile_config_1.resolvePresets)([preset]);
    let schemaResult;
    let stopWatchingPromise = null;
    let released = false;
    let server;
    if (resolvedPreset.grafserv?.watch) {
        schemaResult = (0, grafast_1.defer)();
        stopWatchingPromise = (0, graphile_build_1.watchSchema)(preset, (error, newParams) => {
            if (error || !newParams) {
                console.error("Watch error: ", error);
                if (!released) {
                    released = true;
                    if (server) {
                        server.release().then(null, noop);
                    }
                }
                return;
            }
            const oldSchemaResult = schemaResult;
            schemaResult = newParams;
            if (oldSchemaResult !== null &&
                "resolve" in oldSchemaResult &&
                typeof oldSchemaResult.resolve === "function") {
                oldSchemaResult.resolve(schemaResult);
            }
            if (server) {
                server.setPreset(schemaResult.resolvedPreset);
                server.setSchema(schemaResult.schema);
            }
        });
    }
    else {
        schemaResult = (0, graphile_build_1.makeSchema)(preset);
    }
    function assertAlive() {
        if (released) {
            throw new Error(`PostGraphile instance has been released`);
        }
    }
    return {
        createServ(grafserv) {
            assertAlive();
            if (server) {
                throw new Error(`createServ is currently only allowed to be called once; if you'd like to call it multiple times please file an issue with your use case and we can discuss implementing that.`);
            }
            const schema = (0, grafast_1.isPromiseLike)(schemaResult)
                ? schemaResult.then((p) => p.schema)
                : schemaResult.schema;
            const newServer = grafserv({
                preset,
                schema,
            });
            newServer.onRelease(() => {
                if (!released) {
                    throw new Error(`Grafserv instance released before PostGraphile instance; this is forbidden.`);
                }
            });
            server = newServer;
            return newServer;
        },
        async getSchemaResult() {
            assertAlive();
            return schemaResult;
        },
        async getSchema() {
            assertAlive();
            return (await schemaResult).schema;
        },
        getResolvedPreset() {
            return resolvedPreset;
        },
        async release() {
            assertAlive();
            released = true;
            if (server) {
                await server.release();
            }
            if (stopWatchingPromise) {
                try {
                    const cb = await stopWatchingPromise;
                    cb();
                }
                catch (e) {
                    /* nom nom nom */
                }
            }
        },
    };
}
exports.postgraphile = postgraphile;
exports.default = postgraphile;
//# sourceMappingURL=index.js.map