"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.V4Preset = exports.makeV4Preset = exports.PgV4SmartTagsPlugin = exports.PgV4InflectionPlugin = exports.PgV4BehaviorPlugin = void 0;
require("graphile-config");
const grafserv_1 = require("grafserv");
const PgV4BehaviorPlugin_js_1 = require("../plugins/PgV4BehaviorPlugin.js");
Object.defineProperty(exports, "PgV4BehaviorPlugin", { enumerable: true, get: function () { return PgV4BehaviorPlugin_js_1.PgV4BehaviorPlugin; } });
const PgV4InflectionPlugin_js_1 = require("../plugins/PgV4InflectionPlugin.js");
Object.defineProperty(exports, "PgV4InflectionPlugin", { enumerable: true, get: function () { return PgV4InflectionPlugin_js_1.PgV4InflectionPlugin; } });
const PgV4SmartTagsPlugin_js_1 = require("../plugins/PgV4SmartTagsPlugin.js");
Object.defineProperty(exports, "PgV4SmartTagsPlugin", { enumerable: true, get: function () { return PgV4SmartTagsPlugin_js_1.PgV4SmartTagsPlugin; } });
function isNotNullish(arg) {
    return arg != null;
}
const makeV4Plugin = (options) => {
    const { classicIds = false } = options;
    const simpleCollectionsBehavior = (() => {
        switch (options.simpleCollections) {
            case "both": {
                return "+connection +resource:connection +list +resource:list";
            }
            case "only": {
                return "-connection -resource:connection +list +resource:list";
            }
            case "omit": {
                return "+connection +resource:connection -list -resource:list";
            }
            default: {
                return "";
            }
        }
    })();
    return {
        name: "PostGraphileV4CompatibilityPlugin",
        version: "0.0.0",
        inflection: {
            ignoreReplaceIfNotExists: ["nodeIdFieldName"],
            replace: {
                ...(classicIds ||
                    options.skipPlugins?.some((p) => p.name === "NodePlugin")
                    ? null
                    : {
                        // Rename GraphQL Global Object Identification 'id' to 'nodeId'
                        // TODO: this will be better as `_id` in general, but V4 uses `nodeId`
                        nodeIdFieldName() {
                            return "nodeId";
                        },
                    }),
                ...(classicIds
                    ? null
                    : {
                        // Don't rename 'id' to 'rowId'
                        attribute(previous, options, details) {
                            const attributeFieldName = this.camelCase(this._attributeName(details));
                            return attributeFieldName;
                        },
                    }),
            },
        },
        schema: {
            // We could base this on the legacy relations setting; but how to set deprecated?
            globalBehavior(behavior) {
                return `${behavior} ${simpleCollectionsBehavior} -singularRelation:resource:connection -singularRelation:resource:list`;
            },
        },
    };
};
function parseJWTType(type) {
    const parts = type.split(".");
    // TODO: parse this better!
    if (parts.length !== 2) {
        throw new Error("Cannot parse JWT type - it must have schema and type name separated by a period");
    }
    return parts.map((part) => {
        if (part[0] === '"') {
            if (part[part.length - 1] !== '"') {
                throw new Error(`Cannot parse JWT type; invalid quoting '${part}'`);
            }
            return part.slice(1, part.length - 1);
        }
        else {
            return part;
        }
    });
}
const makeV4Preset = (options = {}) => {
    const { pgUseCustomNetworkScalars, pgStrictFunctions, orderByNullsLast, ...otherGraphileBuildOptions } = options.graphileBuildOptions ?? {};
    if (options.enableQueryBatching) {
        throw new Error(`As of PostGraphile v5, query batching is no longer supported. Query batching has not been standardized as part of the GraphQL-over-HTTP specification efforts, and the need for it has been significantly reduced with the ubiquity of HTTP2+ servers. Further, with incremental delivery (@stream/@defer) on the horizon, query batching will develop a lot of unnecessary complexity that handling at the network layer would bypass.`);
    }
    const graphqlPath = options.graphqlRoute ?? "/graphql";
    const graphiqlPath = options.graphiqlRoute ?? "/graphiql";
    const eventStreamPath = options.eventStreamRoute ?? `${graphqlPath}/stream`;
    return {
        plugins: [
            PgV4InflectionPlugin_js_1.PgV4InflectionPlugin,
            PgV4SmartTagsPlugin_js_1.PgV4SmartTagsPlugin,
            PgV4BehaviorPlugin_js_1.PgV4BehaviorPlugin,
            makeV4Plugin(options),
            ...(options.appendPlugins ? options.appendPlugins : []),
        ].filter(isNotNullish),
        disablePlugins: [
            ...(options.disableDefaultMutations
                ? ["PgMutationCreatePlugin", "PgMutationUpdateDeletePlugin"]
                : []),
            ...(options.skipPlugins ? options.skipPlugins.map((p) => p.name) : []),
            ...(options.ignoreRBAC !== false ? ["PgRBACPlugin"] : []),
            ...(options.ignoreIndexes === false ? [] : ["PgIndexBehaviorsPlugin"]),
        ],
        schema: {
            ...otherGraphileBuildOptions,
            ...{ simpleCollections: options.simpleCollections },
            pgUseCustomNetworkScalars: pgUseCustomNetworkScalars ?? false,
            pgOrderByNullsLast: orderByNullsLast,
            pgV4UseTableNameForNodeIdentifier: true,
            pgForbidSetofFunctionsToReturnNull: options.setofFunctionsContainNulls === false,
            jsonScalarAsString: options.dynamicJson !== true,
            ...(options.jwtSecret != null
                ? {
                    pgJwtSecret: options.jwtSecret,
                }
                : null),
            ...(options.retryOnInitFail
                ? { retryOnInitFail: options.retryOnInitFail }
                : null),
            exportSchemaSDLPath: options.exportGqlSchemaPath,
            exportSchemaIntrospectionResultPath: options.exportJsonSchemaPath,
            sortExport: options.sortExport,
        },
        gather: {
            pgFakeConstraintsAutofixForeignKeyUniqueness: true,
            pgStrictFunctions,
            ...(options.jwtPgTypeIdentifier
                ? {
                    pgJwtType: parseJWTType(options.jwtPgTypeIdentifier),
                }
                : null),
        },
        grafast: {
            ...(options.additionalGraphQLContextFromRequest || options.pgSettings
                ? {
                    async context(ctx) {
                        const context = Object.create(null);
                        const req = ctx.node?.req ?? ctx.ws?.request;
                        const res = ctx.node?.res ?? ctx.ws?.request?.res;
                        if (options.additionalGraphQLContextFromRequest) {
                            if (!req || !res) {
                                console.warn(`Could not determine req/res to use for additionalGraphQLContextFromRequest call.`);
                                console.warn(ctx);
                            }
                            const addl = await options.additionalGraphQLContextFromRequest(req, res);
                            Object.assign(context, addl);
                        }
                        if (options.pgSettings) {
                            if (!req && typeof options.pgSettings === "function") {
                                console.warn(`Could not determine req to use for pgSettings call.`);
                                console.warn(ctx);
                            }
                            const pgSettings = typeof options.pgSettings === "function"
                                ? await options.pgSettings(req)
                                : options.pgSettings;
                            Object.assign(context, { pgSettings });
                        }
                        return context;
                    },
                }
                : null),
            ...(options.allowExplain
                ? {
                    explain: true,
                }
                : null),
        },
        grafserv: {
            graphqlPath,
            graphiqlPath,
            eventStreamPath,
            graphiql: options.graphiql ?? false,
            ...(options.handleErrors
                ? {
                    maskError(error) {
                        return options.handleErrors([error])[0];
                    },
                }
                : null),
            watch: options.watchPg,
            websockets: options.subscriptions,
            allowedRequestContentTypes: [
                ...grafserv_1.DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES,
                "application/x-www-form-urlencoded",
            ],
        },
    };
};
exports.makeV4Preset = makeV4Preset;
exports.V4Preset = (0, exports.makeV4Preset)();
exports.default = exports.V4Preset;
//# sourceMappingURL=v4.js.map