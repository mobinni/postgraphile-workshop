"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("./global.js");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const graphql_1 = require("graphql");
const graphql = tslib_1.__importStar(require("graphql"));
const semver = tslib_1.__importStar(require("semver"));
const util_1 = require("util");
const extend_js_1 = tslib_1.__importStar(require("./extend.js"));
const utils_js_1 = require("./utils.js");
// TODO: the versioning!
const version = "TODO";
/*
import { readFileSync } from "fs";
import { URL } from "url";
const version: string = JSON.parse(
  readFileSync(new URL("../package.json", import.meta.url), "utf8"),
).version;
*/
/**
 * Makes a new 'Build' object suitable to be passed through the 'build' hook.
 */
function makeNewBuild(builder, input, inflection) {
    const building = new Set();
    const allTypes = {
        Int: graphql_1.GraphQLInt,
        Float: graphql_1.GraphQLFloat,
        String: graphql_1.GraphQLString,
        Boolean: graphql_1.GraphQLBoolean,
        ID: graphql_1.GraphQLID,
    };
    const allTypesSources = {
        Int: "GraphQL Built-in",
        Float: "GraphQL Built-in",
        String: "GraphQL Built-in",
        Boolean: "GraphQL Built-in",
        ID: "GraphQL Built-in",
    };
    /**
     * Where the type factories are; so we don't construct types until they're needed.
     */
    const typeRegistry = Object.create(null);
    const scopeByType = new Map();
    // TODO: allow registering a previously constructed type.
    function register(klass, typeName, scope, Step, specGenerator, origin) {
        if (!this.status.isBuildPhaseComplete || this.status.isInitPhaseComplete) {
            throw new Error("Types may only be registered in the 'init' phase");
        }
        if (!typeName) {
            throw new Error(`Attempted to register a ${klass.name} with empty (or falsy) type name`);
        }
        const newTypeSource = origin || `'addType' call during hook '${build.status.currentHookName}'`;
        if (allTypesSources[typeName]) {
            const oldTypeSource = allTypesSources[typeName];
            const firstEntityDetails = !oldTypeSource
                ? "The first type was registered from an unknown origin."
                : `The first entity was:\n\n${(0, extend_js_1.indent)(chalk_1.default.magenta(oldTypeSource))}`;
            const secondEntityDetails = !newTypeSource
                ? "The second type was registered from an unknown origin."
                : `The second entity was:\n\n${(0, extend_js_1.indent)(chalk_1.default.yellow(newTypeSource))}`;
            throw new Error(`A type naming conflict has occurred - two entities have tried to define the same type '${chalk_1.default.bold(typeName)}'.\n\n${(0, extend_js_1.indent)(firstEntityDetails)}\n\n${(0, extend_js_1.indent)(secondEntityDetails)}`);
        }
        allTypesSources[typeName] = newTypeSource;
        typeRegistry[typeName] = {
            klass,
            scope,
            specGenerator,
            origin,
            Step,
        };
    }
    const build = {
        options: builder.options,
        versions: {
            graphql: graphql.version,
            "graphile-build": version,
        },
        input,
        hasVersion(packageName, range, options = { includePrerelease: true }) {
            const packageVersion = this.versions[packageName];
            if (!packageVersion)
                return false;
            return semver.satisfies(packageVersion, range, options);
        },
        graphql,
        extend(base, extra, hint, behaviorOnConflict = "throw") {
            try {
                return (0, extend_js_1.default)(base, extra, hint);
            }
            catch (e) {
                if (behaviorOnConflict === "recoverable") {
                    this.handleRecoverableError(e);
                    return base;
                }
                else {
                    throw e;
                }
            }
        },
        getAllTypes() {
            return allTypes;
        },
        scopeByType,
        inflection,
        handleRecoverableError(e) {
            e["recoverable"] = true;
            throw e;
        },
        recoverable(value, callback) {
            try {
                return callback();
            }
            catch (e) {
                this.handleRecoverableError(e);
                return value;
            }
        },
        status: {
            isBuildPhaseComplete: false,
            isInitPhaseComplete: false,
            currentHookName: null,
            currentHookEvent: null,
        },
        wrapDescription: utils_js_1.wrapDescription,
        stringTypeSpec: utils_js_1.stringTypeSpec,
        registerObjectType(typeName, scope, Step, specGenerator, origin) {
            register.call(this, graphql_1.GraphQLObjectType, typeName, scope, Step, specGenerator, origin);
        },
        registerUnionType(typeName, scope, specGenerator, origin) {
            register.call(this, graphql_1.GraphQLUnionType, typeName, scope, null, specGenerator, origin);
        },
        registerInterfaceType(typeName, scope, specGenerator, origin) {
            register.call(this, graphql_1.GraphQLInterfaceType, typeName, scope, null, specGenerator, origin);
        },
        registerInputObjectType(typeName, scope, specGenerator, origin) {
            register.call(this, graphql_1.GraphQLInputObjectType, typeName, scope, null, specGenerator, origin);
        },
        registerScalarType(typeName, scope, specGenerator, origin) {
            register.call(this, graphql_1.GraphQLScalarType, typeName, scope, null, specGenerator, origin);
        },
        registerEnumType(typeName, scope, specGenerator, origin) {
            register.call(this, graphql_1.GraphQLEnumType, typeName, scope, null, specGenerator, origin);
        },
        assertTypeName(typeName) {
            if (!this.status.isBuildPhaseComplete) {
                throw new Error("Must not call build.assertTypeName before 'build' phase is complete");
            }
            if (typeName in allTypesSources) {
                return true;
            }
            else {
                throw new Error(`Type name '${typeName}' is not registered - be sure to register the type before you attempt to reference it.`);
            }
        },
        getTypeMetaByName(typeName) {
            if (!this.status.isBuildPhaseComplete) {
                throw new Error("Must not call build.getTypeMetaByName before 'build' phase is complete");
            }
            // Meta for builtins
            switch (typeName) {
                case "String":
                case "ID":
                case "Boolean":
                case "Int":
                case "Float":
                    return Object.assign(Object.create(null), {
                        Constructor: graphql_1.GraphQLScalarType,
                        scope: Object.freeze({}),
                        origin: "GraphQL builtin",
                    });
            }
            const details = typeRegistry[typeName];
            if (details != null) {
                const { klass: Constructor, scope, origin, Step } = details;
                return Object.assign(Object.create(null), {
                    Constructor,
                    scope,
                    origin,
                    Step,
                });
            }
            return null;
        },
        getTypeByName(typeName) {
            if (!this.status.isInitPhaseComplete) {
                throw new Error("Must not call build.getTypeByName before 'init' phase is complete");
            }
            if (typeName in allTypes) {
                return allTypes[typeName];
            }
            else if (building.has(typeName)) {
                throw new Error(`Construction cycle detected: ${typeName} is already being built. Most likely this means that you forgot to use a callback for 'fields', 'interfaces', 'types', etc. when defining a type.`);
            }
            else {
                building.add(typeName);
                try {
                    const details = typeRegistry[typeName];
                    if (details != null) {
                        const { klass, scope, specGenerator, Step } = details;
                        const spec = specGenerator();
                        // No need to have the user specify name, and they're forbidden from
                        // changing name (use inflection instead!) so we just set it
                        // ourselves:
                        spec.name = typeName;
                        const finishedBuild = build;
                        const type = builder.newWithHooks(finishedBuild, klass, spec, scope, Step);
                        allTypes[typeName] = type;
                        if (klass === graphql_1.GraphQLObjectType ||
                            klass === graphql_1.GraphQLInputObjectType) {
                            // Perform fields check. It's critical that `allTypes[typeName]` is
                            // set above this to prevent infinite loops in case one of our
                            // fields is dependent on another type, which is in turn dependent
                            // on this type - in this case we know there's at least one field
                            // otherwise the conflict would not occur?
                            if (Object.keys(type.getFields()).length === 0) {
                                allTypes[typeName] = null;
                                return null;
                            }
                        }
                        return type;
                    }
                    else {
                        allTypes[typeName] = undefined;
                        return undefined;
                    }
                }
                catch (e) {
                    // Error occurred, store null
                    allTypes[typeName] = null;
                    // Rethrow error
                    throw e;
                }
                finally {
                    building.delete(typeName);
                }
            }
        },
        getInputTypeByName(typeName) {
            if (!this.status.isInitPhaseComplete) {
                throw new Error("Must not call build.getInputTypeByName before 'init' phase is complete");
            }
            const type = this.getTypeByName(typeName);
            if (!type || !(0, graphql_1.isInputType)(type)) {
                throw new Error(`Expected an input type named '${typeName}', instead found ${String(type)}`);
            }
            return type;
        },
        getOutputTypeByName(typeName) {
            if (!this.status.isInitPhaseComplete) {
                throw new Error("Must not call build.getOutputTypeByName before 'init' phase is complete");
            }
            const type = this.getTypeByName(typeName);
            if (!type || !(0, graphql_1.isOutputType)(type)) {
                throw new Error(`Expected an output type named '${typeName}', instead found ${(0, util_1.inspect)(type)}`);
            }
            return type;
        },
        nullableIf(condition, type) {
            if (condition) {
                return type;
            }
            else {
                return new graphql.GraphQLNonNull(type);
            }
        },
        _pluginMeta: Object.create(null),
    };
    return build;
}
exports.default = makeNewBuild;
//# sourceMappingURL=makeNewBuild.js.map