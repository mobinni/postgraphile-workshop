import "./global.js";
import "./interfaces.js";
import type { GraphQLSchema } from "graphql";
import { AddNodeInterfaceToSuitableTypesPlugin, BuiltinScalarConnectionsPlugin, ClientMutationIdDescriptionPlugin, CommonTypesPlugin, CursorTypePlugin, MutationPayloadQueryPlugin, MutationPlugin, NodeAccessorPlugin, NodeIdCodecBase64JSONPlugin, NodeIdCodecPipeStringPlugin, NodePlugin, PageInfoStartEndCursorPlugin, QueryPlugin, QueryQueryPlugin, RegisterQueryNodePlugin, StreamDeferPlugin, SubscriptionPlugin, SwallowErrorsPlugin, TrimEmptyDescriptionsPlugin } from "./plugins/index.js";
import SchemaBuilder from "./SchemaBuilder.js";
export { camelCase, constantCase, constantCaseAll, EXPORTABLE, formatInsideUnderscores, pluralize, singularize, upperCamelCase, upperFirst, } from "./utils.js";
import type { NewWithHooksFunction } from "./newWithHooks/index.js";
export { GraphileBuild, GraphileConfig };
export { NewWithHooksFunction, SchemaBuilder };
/**
 * Generate 'build.inflection' from the given preset.
 */
export declare const buildInflection: (preset: GraphileConfig.Preset) => GraphileBuild.Inflection;
/**
 * One-time gather. See `watchGather` for watch mode.
 */
export declare const gather: (preset: GraphileConfig.Preset, helpers?: {
    inflection: GraphileBuild.Inflection;
}) => Promise<GraphileBuild.BuildInput>;
/**
 * Tells your gather plugins to monitor their sources, and passes the resulting
 * BuildInput to the callback each time a new one is generated. It is
 * guaranteed that the `callback` will be called at least once before the
 * promise resolves.
 *
 * @returns A callback to call to stop watching.
 */
export declare const watchGather: (preset: GraphileConfig.Preset, helpers: {
    inflection: GraphileBuild.Inflection;
} | undefined, callback: (gather: GraphileBuild.BuildInput | null, error: Error | undefined, retry: () => void) => void) => Promise<() => void>;
/**
 * Gets a SchemaBuilder object for the given preset and inflection.  It's rare
 * you would need this, typically you'll want `buildSchema` instead.
 */
export declare const getBuilder: (preset: GraphileConfig.Preset, inflection?: GraphileBuild.Inflection) => SchemaBuilder;
/**
 * Builds a GraphQL schema according to the given preset and input data.
 */
export declare const buildSchema: (preset: GraphileConfig.Preset, input: GraphileBuild.BuildInput, shared?: {
    inflection?: GraphileBuild.Inflection;
}) => GraphQLSchema;
export { AddNodeInterfaceToSuitableTypesPlugin, BuiltinScalarConnectionsPlugin, ClientMutationIdDescriptionPlugin, CommonTypesPlugin, CursorTypePlugin, MutationPayloadQueryPlugin, MutationPlugin, NodeAccessorPlugin, NodeIdCodecBase64JSONPlugin, NodeIdCodecPipeStringPlugin, NodePlugin, PageInfoStartEndCursorPlugin, QueryPlugin, QueryQueryPlugin, RegisterQueryNodePlugin, StreamDeferPlugin, SubscriptionPlugin, SwallowErrorsPlugin, TrimEmptyDescriptionsPlugin, };
export { GatherPluginContext } from "./interfaces.js";
export { defaultPreset } from "./preset.js";
export interface SchemaResult {
    schema: GraphQLSchema;
    resolvedPreset: GraphileConfig.ResolvedPreset;
}
/**
 * Builds the GraphQL schema by resolving the preset, running inflection then
 * gather and building the schema. Returns the results.
 *
 * @experimental
 */
export declare function makeSchema(preset: GraphileConfig.Preset): Promise<SchemaResult>;
/**
 * Runs the "gather" phase in watch mode and calls 'callback' with the
 * generated SchemaResult each time a new schema is generated.
 *
 * It is guaranteed that `callback` will be called at least once before the
 * promise resolves.
 *
 * Returns a function that can be called to stop watching.
 *
 * @experimental
 */
export declare function watchSchema(preset: GraphileConfig.Preset, callback: (fatalError: Error | null, params?: SchemaResult) => void): Promise<() => void>;
//# sourceMappingURL=index.d.ts.map