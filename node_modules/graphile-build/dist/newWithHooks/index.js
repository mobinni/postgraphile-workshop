"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeNewWithHooks = void 0;
const grafast_1 = require("grafast");
const graphql_1 = require("graphql");
const util_1 = require("util");
const isString = (str) => typeof str === "string";
const knownTypes = [
    graphql_1.GraphQLSchema,
    graphql_1.GraphQLObjectType,
    graphql_1.GraphQLInterfaceType,
    graphql_1.GraphQLUnionType,
    graphql_1.GraphQLInputObjectType,
    graphql_1.GraphQLEnumType,
    graphql_1.GraphQLScalarType,
];
const knownTypeNames = knownTypes.map((k) => k.name);
/**
 * Returns a 'newWithHooks' function suitable for creating GraphQL types with
 * the graphile-build plugin system applied.
 */
function makeNewWithHooks({ builder }) {
    const newWithHooks = function newWithHooks(build, Type, inSpec, inScope, Step) {
        if (!inScope) {
            // eslint-disable-next-line no-console
            console.warn(`No scope was provided to new ${Type.name}${"name" in inSpec ? `[name=${inSpec.name}]` : ``}, it's highly recommended that you add a scope so other hooks can easily reference your object - please check usage of 'newWithHooks'. To mute this message, just pass an empty object.`);
        }
        if (!Type) {
            throw new Error("No type specified!");
        }
        if (knownTypes.indexOf(Type) === -1 &&
            knownTypeNames.indexOf(Type.name) >= 0) {
            throw new Error(`GraphQL conflict for '${Type.name}' detected! Multiple versions of graphql exist in your node_` +
                /* yarn doctor */ `modules?`);
        }
        const Result = (() => {
            switch (Type) {
                case graphql_1.GraphQLSchema: {
                    const rawSpec = inSpec;
                    const scope = (inScope ||
                        Object.create(null));
                    const context = {
                        type: "GraphQLSchema",
                        scope,
                    };
                    const finalSpec = builder.applyHooks("GraphQLSchema", rawSpec, build, context);
                    finalSpec.types = builder.applyHooks("GraphQLSchema_types", [...(finalSpec.types ?? [])], build, context);
                    const Self = new graphql_1.GraphQLSchema(finalSpec);
                    return Self;
                }
                case graphql_1.GraphQLObjectType: {
                    const rawSpec = inSpec;
                    const scope = (inScope ||
                        Object.create(null));
                    const objectContext = {
                        type: "GraphQLObjectType",
                        scope,
                    };
                    const baseSpec = builder.applyHooks("GraphQLObjectType", rawSpec, build, objectContext, `|${rawSpec.name}`);
                    const finalSpec = {
                        ...baseSpec,
                        interfaces: () => {
                            const interfacesContext = {
                                ...objectContext,
                                Self,
                            };
                            let rawInterfaces = rawSpec.interfaces || [];
                            if (typeof rawInterfaces === "function") {
                                rawInterfaces = rawInterfaces(interfacesContext);
                            }
                            return builder.applyHooks("GraphQLObjectType_interfaces", rawInterfaces, build, interfacesContext, `|${Self.name}`);
                        },
                        fields: () => {
                            const processedFields = [];
                            const fieldWithHooks = (fieldScope, fieldSpec) => {
                                const { fieldName } = fieldScope;
                                build.extend(fieldScope, scope, "Adding the object type scope to the field's scope");
                                if (!isString(fieldName)) {
                                    throw new Error("It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.");
                                }
                                if (!fieldScope) {
                                    throw new Error("All calls to `fieldWithHooks` must specify a `fieldScope` " +
                                        "argument that gives additional context about the field so " +
                                        "that further plugins may more easily understand the field. " +
                                        "Keys within this object should contain the phrase 'field' " +
                                        "since they will be merged into the parent objects scope and " +
                                        "are not allowed to clash. If you really have no additional " +
                                        "information to give, please just pass `{}`.");
                                }
                                const fieldContext = {
                                    ...fieldsContext,
                                    scope: fieldScope,
                                };
                                let resolvedFieldSpec = typeof fieldSpec === "function"
                                    ? fieldSpec(fieldContext)
                                    : fieldSpec;
                                resolvedFieldSpec = builder.applyHooks("GraphQLObjectType_fields_field", resolvedFieldSpec, build, fieldContext, `|${Self.name}.fields.${fieldName}`);
                                resolvedFieldSpec.args = resolvedFieldSpec.args ?? {};
                                const argsContext = {
                                    ...fieldContext,
                                };
                                const finalFieldSpec = {
                                    ...resolvedFieldSpec,
                                    args: builder.applyHooks("GraphQLObjectType_fields_field_args", resolvedFieldSpec.args, build, argsContext, `|${Self.name}.fields.${fieldName}.args`),
                                };
                                for (const [argName, argSpec] of Object.entries(finalFieldSpec.args)) {
                                    if (!argName) {
                                        throw new Error(`Attempted to add empty/falsy argName to GraphQLObjectType ${Self.name}'s '${fieldName}' field; ${(0, util_1.inspect)(argSpec)}`);
                                    }
                                    const argContext = {
                                        ...argsContext,
                                        scope: {
                                            ...argsContext.scope,
                                            argName,
                                        },
                                    };
                                    finalFieldSpec.args[argName] = builder.applyHooks("GraphQLObjectType_fields_field_args_arg", argSpec, build, argContext, `|${Self.name}.fields.${fieldName}.args.${argName}`);
                                }
                                processedFields.push(finalFieldSpec);
                                return finalFieldSpec;
                            };
                            const fieldsContext = {
                                ...objectContext,
                                Self: Self,
                                fieldWithHooks,
                            };
                            const rawFields = typeof rawSpec.fields === "function"
                                ? rawSpec.fields(fieldsContext)
                                : rawSpec.fields || {};
                            const fieldsSpec = builder.applyHooks("GraphQLObjectType_fields", build.extend(Object.create(null), rawFields, `Default field included in newWithHooks call for '${rawSpec.name}'. ${inScope.__origin || ""}`), build, fieldsContext, `|${rawSpec.name}`);
                            // Finally, check through all the fields that they've all been
                            // processed; any that have not we should do so now.
                            for (const [fieldName, fieldSpec] of Object.entries(fieldsSpec)) {
                                if (!fieldName) {
                                    throw new Error(`Attempted to add empty/falsy fieldName to GraphQLObjectType ${Self.name}; ${(0, util_1.inspect)(fieldSpec)}`);
                                }
                                if (processedFields.indexOf(fieldSpec) < 0) {
                                    // We've not processed this yet; process it now!
                                    fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(
                                    // We don't have any additional information
                                    { fieldName }, fieldSpec);
                                }
                            }
                            return fieldsSpec;
                        },
                    };
                    const Self = new graphql_1.GraphQLObjectType((0, grafast_1.objectSpec)(finalSpec, Step ?? null));
                    return Self;
                }
                case graphql_1.GraphQLInterfaceType: {
                    const rawSpec = inSpec;
                    const scope = (inScope ||
                        Object.create(null));
                    const interfaceContext = {
                        type: "GraphQLInterfaceType",
                        scope,
                    };
                    const baseSpec = builder.applyHooks("GraphQLInterfaceType", rawSpec, build, interfaceContext, `|${rawSpec.name}`);
                    const finalSpec = {
                        ...baseSpec,
                        fields: () => {
                            const processedFields = [];
                            const fieldsContext = {
                                ...interfaceContext,
                                Self,
                                fieldWithHooks: (fieldScope, fieldSpec) => {
                                    const { fieldName } = fieldScope;
                                    build.extend(fieldScope, scope, "Adding interface scope to interface's field scope");
                                    if (!isString(fieldName)) {
                                        throw new Error("It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is currently necessary.");
                                    }
                                    if (!fieldScope) {
                                        throw new Error("All calls to `fieldWithHooks` must specify a `fieldScope` " +
                                            "argument that gives additional context about the field so " +
                                            "that further plugins may more easily understand the field. " +
                                            "Keys within this object should contain the phrase 'field' " +
                                            "since they will be merged into the parent objects scope and " +
                                            "are not allowed to clash. If you really have no additional " +
                                            "information to give, please just pass `{}`.");
                                    }
                                    const fieldContext = {
                                        ...fieldsContext,
                                        scope: fieldScope,
                                    };
                                    let newSpec = typeof fieldSpec === "function"
                                        ? fieldSpec(fieldContext)
                                        : fieldSpec;
                                    newSpec = builder.applyHooks("GraphQLInterfaceType_fields_field", newSpec, build, fieldContext, `|${Self.name}.fields.${fieldName}`);
                                    newSpec.args = newSpec.args || {};
                                    const argsContext = {
                                        ...fieldContext,
                                    };
                                    newSpec = {
                                        ...newSpec,
                                        args: builder.applyHooks("GraphQLInterfaceType_fields_field_args", newSpec.args ?? Object.create(null), build, argsContext, `|${Self.name}.fields.${fieldName}.args`),
                                    };
                                    const finalFieldSpec = newSpec;
                                    for (const [argName, argSpec] of Object.entries(finalFieldSpec.args)) {
                                        if (!argName) {
                                            throw new Error(`Attempted to add empty/falsy argName to GraphQLInterfaceType ${Self.name}'s '${fieldName}' field; ${(0, util_1.inspect)(argSpec)}`);
                                        }
                                        const argContext = {
                                            ...argsContext,
                                            scope: {
                                                ...argsContext.scope,
                                                argName,
                                            },
                                        };
                                        finalFieldSpec.args[argName] = builder.applyHooks("GraphQLInterfaceType_fields_field_args_arg", argSpec, build, argContext, `|${Self.name}.fields.${fieldName}.args.${argName}`);
                                    }
                                    processedFields.push(finalFieldSpec);
                                    return finalFieldSpec;
                                },
                            };
                            const rawFields = (typeof rawSpec.fields === "function"
                                ? rawSpec.fields(fieldsContext)
                                : rawSpec.fields) || {};
                            const fieldsSpec = builder.applyHooks("GraphQLInterfaceType_fields", build.extend(Object.create(null), rawFields, `Default field included in newWithHooks call for '${rawSpec.name}'. ${inScope.__origin || ""}`), build, fieldsContext, `|${rawSpec.name}`);
                            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.
                            for (const [fieldName, fieldSpec] of Object.entries(fieldsSpec)) {
                                if (!fieldName) {
                                    throw new Error(`Attempted to add empty/falsy fieldName to GraphQLInterfaceType ${Self.name}; ${(0, util_1.inspect)(fieldSpec)}`);
                                }
                                if (processedFields.indexOf(fieldSpec) < 0) {
                                    // We've not processed this yet; process it now!
                                    fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(
                                    // We don't have any additional information
                                    { fieldName }, fieldSpec);
                                }
                            }
                            return fieldsSpec;
                        },
                        interfaces: () => {
                            const interfacesContext = {
                                ...interfaceContext,
                                Self,
                            };
                            const rawInterfaces = (typeof rawSpec.interfaces === "function"
                                ? rawSpec.interfaces(interfacesContext)
                                : rawSpec.interfaces) || [];
                            const interfacesSpec = builder.applyHooks("GraphQLInterfaceType_interfaces", rawInterfaces, build, interfacesContext, `|${rawSpec.name}`);
                            return interfacesSpec;
                        },
                    };
                    const Self = new graphql_1.GraphQLInterfaceType(finalSpec);
                    return Self;
                }
                case graphql_1.GraphQLUnionType: {
                    const rawSpec = inSpec;
                    const scope = (inScope ||
                        Object.create(null));
                    const commonContext = {
                        type: "GraphQLUnionType",
                        scope,
                    };
                    const baseSpec = builder.applyHooks("GraphQLUnionType", rawSpec, build, commonContext, `|${rawSpec.name}`);
                    const finalSpec = {
                        ...baseSpec,
                        types: () => {
                            const typesContext = {
                                ...commonContext,
                                Self,
                            };
                            const rawTypes = (typeof baseSpec.types === "function"
                                ? baseSpec.types(typesContext)
                                : baseSpec.types) || [];
                            return builder.applyHooks("GraphQLUnionType_types", rawTypes, build, typesContext, `|${Self.name}`);
                        },
                    };
                    const Self = new graphql_1.GraphQLUnionType(finalSpec);
                    return Self;
                }
                case graphql_1.GraphQLInputObjectType: {
                    const rawSpec = inSpec;
                    const scope = (inScope ||
                        Object.create(null));
                    const inputObjectContext = {
                        type: "GraphQLInputObjectType",
                        scope,
                    };
                    const baseSpec = builder.applyHooks("GraphQLInputObjectType", rawSpec, build, inputObjectContext, `|${rawSpec.name}`);
                    const finalSpec = {
                        ...baseSpec,
                        fields: () => {
                            const processedFields = [];
                            const fieldWithHooks = (fieldScope, spec) => {
                                const { fieldName } = fieldScope;
                                if (!isString(fieldName)) {
                                    throw new Error("It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.");
                                }
                                const finalFieldScope = build.extend(fieldScope, scope, `Extending scope for field '${fieldName}' within context for GraphQLInputObjectType '${rawSpec.name}'`);
                                const fieldContext = {
                                    ...fieldsContext,
                                    scope: finalFieldScope,
                                };
                                let newSpec = typeof spec === "function" ? spec(fieldContext) : spec;
                                newSpec = builder.applyHooks("GraphQLInputObjectType_fields_field", newSpec, build, fieldContext, `|${Self.name}.fields.${fieldName}`);
                                const finalSpec = newSpec;
                                processedFields.push(finalSpec);
                                return finalSpec;
                            };
                            const fieldsContext = {
                                ...inputObjectContext,
                                Self,
                                fieldWithHooks,
                            };
                            const rawFields = (typeof rawSpec.fields === "function"
                                ? rawSpec.fields(fieldsContext)
                                : rawSpec.fields) || {};
                            const fieldsList = build.extend(Object.create(null), rawFields, `Default field included in newWithHooks call for '${rawSpec.name}'. ${inScope.__origin || ""}`);
                            const fieldsSpec = builder.applyHooks("GraphQLInputObjectType_fields", fieldsList, build, fieldsContext, `|${Self.name}`);
                            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.
                            for (const [fieldName, fieldSpec] of Object.entries(fieldsSpec)) {
                                if (!fieldName) {
                                    throw new Error(`Attempted to add empty/falsy fieldName to GraphQLInputObjectType ${Self.name}; ${(0, util_1.inspect)(fieldSpec)}`);
                                }
                                if (processedFields.indexOf(fieldSpec) < 0) {
                                    // We've not processed this yet; process it now!
                                    fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(
                                    // We don't have any additional information
                                    { fieldName }, fieldSpec);
                                }
                                fieldsSpec[fieldName] = (0, grafast_1.inputObjectFieldSpec)(fieldsSpec[fieldName], `${Self.name}.${fieldName}`);
                            }
                            return fieldsSpec;
                        },
                    };
                    const Self = new graphql_1.GraphQLInputObjectType(finalSpec);
                    return Self;
                }
                case graphql_1.GraphQLScalarType: {
                    const rawSpec = inSpec;
                    const scope = (inScope ||
                        Object.create(null));
                    const scalarContext = {
                        type: "GraphQLScalarType",
                        scope,
                    };
                    const finalSpec = builder.applyHooks("GraphQLScalarType", rawSpec, build, scalarContext, `|${rawSpec.name}`);
                    const Self = new graphql_1.GraphQLScalarType(finalSpec);
                    return Self;
                }
                case graphql_1.GraphQLEnumType: {
                    const rawSpec = inSpec;
                    const scope = (inScope ||
                        Object.create(null));
                    const enumContext = {
                        type: "GraphQLEnumType",
                        scope,
                    };
                    const finalSpec = builder.applyHooks("GraphQLEnumType", rawSpec, build, enumContext, `|${rawSpec.name}`);
                    finalSpec.values = builder.applyHooks("GraphQLEnumType_values", finalSpec.values, build, enumContext, `|${finalSpec.name}`);
                    const values = finalSpec.values;
                    finalSpec.values = Object.entries(values).reduce((memo, [valueKey, value]) => {
                        const newValue = builder.applyHooks("GraphQLEnumType_values_value", value, build, enumContext, `|${finalSpec.name}|${valueKey}`);
                        memo[valueKey] = newValue;
                        return memo;
                    }, Object.create(null));
                    const Self = new graphql_1.GraphQLEnumType(finalSpec);
                    return Self;
                }
                default: {
                    throw new Error(`Cannot handle ${Type}`);
                }
            }
        })();
        if ((0, graphql_1.isNamedType)(Result)) {
            build.scopeByType.set(Result, inScope);
        }
        return Result;
    };
    return { newWithHooks };
}
exports.makeNewWithHooks = makeNewWithHooks;
//# sourceMappingURL=index.js.map