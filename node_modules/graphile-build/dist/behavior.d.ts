export type BehaviorDynamicMethods = {
    [entityType in keyof GraphileBuild.BehaviorEntities as `${entityType}Matches`]: (entity: GraphileBuild.BehaviorEntities[entityType], filter: string) => boolean | undefined;
} & {
    [entityType in keyof GraphileBuild.BehaviorEntities as `${entityType}Behavior`]: (entity: GraphileBuild.BehaviorEntities[entityType], applyDefaultBehavior?: boolean) => string;
};
export declare class Behavior {
    private resolvedPreset;
    private build;
    private behaviorEntities;
    private globalDefaultBehavior;
    constructor(resolvedPreset: GraphileConfig.ResolvedPreset, build: GraphileBuild.Build);
    /**
     * Forbid registration of more global behavior defaults, behavior entity types, etc.
     */
    freeze(): Behavior & BehaviorDynamicMethods;
    private registerEntity;
    private assertEntity;
    /**
     * @param localBehaviorSpecsString - the behavior of the entity as determined by details on the entity itself and any applicable ancestors
     * @param filter - the behavior the plugin specifies
     */
    entityMatches<TEntityType extends keyof GraphileBuild.BehaviorEntities>(entityType: TEntityType, entity: GraphileBuild.BehaviorEntities[TEntityType], filter: string): boolean | undefined;
    /**
     * Given the entity `rawEntity` of type `entityType`, this function will
     * return the final behavior string for this entity, respecting all the
     * global and entity-specific behaviors.
     *
     * This is expensive to compute, so we cache it.
     *
     * **IMPORTANT**: `rawEntity` should be a fixed value so that the cache can be
     * reused. If it is a dynamic value (e.g. it's a combination of multiple
     * entities) then you should represent it as a tuple and we'll automatically
     * cache that.
     */
    getBehaviorForEntity<TEntityType extends keyof GraphileBuild.BehaviorEntities>(entityType: TEntityType, rawEntity: GraphileBuild.BehaviorEntities[TEntityType], applyDefaultBehavior?: boolean): ResolvedBehavior;
    /** @deprecated Please use entityMatches or stringMatches instead */
    matches(localBehaviorSpecsString: string | string[] | null | undefined, filter: string, defaultBehavior?: string): boolean | undefined;
}
export declare function joinBehaviors(strings: ReadonlyArray<string | null | undefined>): string;
interface StackItem {
    source: string;
    prefix: string;
    suffix: string;
}
interface ResolvedBehavior {
    stack: ReadonlyArray<StackItem>;
    behaviorString: string;
}
export {};
//# sourceMappingURL=behavior.d.ts.map