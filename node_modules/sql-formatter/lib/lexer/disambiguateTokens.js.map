{"version":3,"file":"disambiguateTokens.js","names":["isReserved","TokenType","disambiguateTokens","tokens","map","dotKeywordToIdent","funcNameToKeyword","identToArrayIdent","keywordToArrayKeyword","token","i","type","prevToken","prevNonCommentToken","text","IDENTIFIER","raw","RESERVED_FUNCTION_NAME","nextToken","nextNonCommentToken","isOpenParen","RESERVED_KEYWORD","isOpenBracket","ARRAY_IDENTIFIER","ARRAY_KEYWORD","index","dir","isComment","t","OPEN_PAREN","BLOCK_COMMENT","LINE_COMMENT"],"sources":["../../src/lexer/disambiguateTokens.ts"],"sourcesContent":["import { isReserved, Token, TokenType } from './token.js';\n\n/**\n * Ensures that no keyword token (RESERVED_*) is preceded by dot (.).\n *\n * Ensures that all RESERVED_FUNCTION_NAME tokens are followed by \"(\".\n * If they're not, converts the token to RESERVED_KEYWORD.\n *\n * When IDENTIFIER and RESERVED_KEYWORD token is followed by \"[\"\n * converts it to ARRAY_IDENTIFIER or ARRAY_KEYWORD accordingly.\n *\n * This is needed to avoid ambiguity in parser which expects function names\n * to always be followed by open-paren, and to distinguish between\n * array accessor `foo[1]` and array literal `[1, 2, 3]`.\n */\nexport function disambiguateTokens(tokens: Token[]): Token[] {\n  return tokens\n    .map(dotKeywordToIdent)\n    .map(funcNameToKeyword)\n    .map(identToArrayIdent)\n    .map(keywordToArrayKeyword);\n}\n\nconst dotKeywordToIdent = (token: Token, i: number, tokens: Token[]): Token => {\n  if (isReserved(token.type)) {\n    const prevToken = prevNonCommentToken(tokens, i);\n    if (prevToken && prevToken.text === '.') {\n      return { ...token, type: TokenType.IDENTIFIER, text: token.raw };\n    }\n  }\n  return token;\n};\n\nconst funcNameToKeyword = (token: Token, i: number, tokens: Token[]): Token => {\n  if (token.type === TokenType.RESERVED_FUNCTION_NAME) {\n    const nextToken = nextNonCommentToken(tokens, i);\n    if (!nextToken || !isOpenParen(nextToken)) {\n      return { ...token, type: TokenType.RESERVED_KEYWORD };\n    }\n  }\n  return token;\n};\n\nconst identToArrayIdent = (token: Token, i: number, tokens: Token[]): Token => {\n  if (token.type === TokenType.IDENTIFIER) {\n    const nextToken = nextNonCommentToken(tokens, i);\n    if (nextToken && isOpenBracket(nextToken)) {\n      return { ...token, type: TokenType.ARRAY_IDENTIFIER };\n    }\n  }\n  return token;\n};\n\nconst keywordToArrayKeyword = (token: Token, i: number, tokens: Token[]): Token => {\n  if (token.type === TokenType.RESERVED_KEYWORD) {\n    const nextToken = nextNonCommentToken(tokens, i);\n    if (nextToken && isOpenBracket(nextToken)) {\n      return { ...token, type: TokenType.ARRAY_KEYWORD };\n    }\n  }\n  return token;\n};\n\nconst prevNonCommentToken = (tokens: Token[], index: number): Token | undefined =>\n  nextNonCommentToken(tokens, index, -1);\n\nconst nextNonCommentToken = (\n  tokens: Token[],\n  index: number,\n  dir: -1 | 1 = 1\n): Token | undefined => {\n  let i = 1;\n  while (tokens[index + i * dir] && isComment(tokens[index + i * dir])) {\n    i++;\n  }\n  return tokens[index + i * dir];\n};\n\nconst isOpenParen = (t: Token): boolean => t.type === TokenType.OPEN_PAREN && t.text === '(';\n\nconst isOpenBracket = (t: Token): boolean => t.type === TokenType.OPEN_PAREN && t.text === '[';\n\nconst isComment = (t: Token): boolean =>\n  t.type === TokenType.BLOCK_COMMENT || t.type === TokenType.LINE_COMMENT;\n"],"mappings":"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"}