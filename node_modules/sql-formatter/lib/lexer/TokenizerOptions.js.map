{"version":3,"file":"TokenizerOptions.js","names":[],"sources":["../../src/lexer/TokenizerOptions.ts"],"sourcesContent":["import { quotePatterns } from './regexFactory.js';\nimport { Token } from './token.js';\n\nexport interface IdentChars {\n  // Additional characters that can be used as first character of an identifier.\n  // That is: in addition to letters and underscore.\n  first?: string;\n  // Additional characters that can appear after the first character of identifier.\n  // That is: in addition to letters, numbers and underscore.\n  rest?: string;\n  // True to allow single dashes (-) inside identifiers, but not at the beginning or end\n  dashes?: boolean;\n  // Allows identifier to begin with number\n  allowFirstCharNumber?: boolean;\n}\n\nexport type PlainQuoteType = keyof typeof quotePatterns;\n\nexport interface PrefixedQuoteType {\n  quote: PlainQuoteType;\n  prefixes: string[];\n  requirePrefix?: boolean; // True when prefix is required\n}\n\nexport interface RegexPattern {\n  regex: string;\n}\n\nexport type QuoteType = PlainQuoteType | PrefixedQuoteType | RegexPattern;\n\nexport type VariableType = RegexPattern | PrefixedQuoteType;\n\nexport interface ParamTypes {\n  // True to allow for positional \"?\" parameter placeholders\n  positional?: boolean;\n  // Prefixes for numbered parameter placeholders to support, e.g. :1, :2, :3\n  numbered?: ('?' | ':' | '$')[];\n  // Prefixes for named parameter placeholders to support, e.g. :name\n  named?: (':' | '@' | '$')[];\n  // Prefixes for quoted parameter placeholders to support, e.g. :\"name\"\n  // The type of quotes will depend on `identifierTypes` option.\n  quoted?: (':' | '@' | '$')[];\n  // Custom parameter type definitions\n  custom?: CustomParameter[];\n}\n\nexport interface CustomParameter {\n  // Regex pattern for matching the parameter\n  regex: string;\n  // Takes the matched parameter string and returns the name of the parameter\n  // For example we might match \"{foo}\" and the name would be \"foo\".\n  key?: (text: string) => string;\n}\n\nexport interface TokenizerOptions {\n  // SELECT clause and its variations\n  reservedSelect: string[];\n  // Main clauses that start new block, like: WITH, FROM, WHERE, ORDER BY\n  reservedClauses: string[];\n  // True to support XOR in addition to AND and OR\n  supportsXor?: boolean;\n  // Keywords that create newline but no indentaion of their body.\n  // These contain set operations like UNION\n  reservedSetOperations: string[];\n  // Various joins like LEFT OUTER JOIN\n  reservedJoins: string[];\n  // These are essentially multi-word sequences of keywords,\n  // that we prioritize over all other keywords (RESERVED_* tokens)\n  reservedPhrases?: string[];\n  // built in function names\n  reservedFunctionNames: string[];\n  // all other reserved words (not included to any of the above lists)\n  reservedKeywords: string[];\n  // Types of quotes to use for strings\n  stringTypes: QuoteType[];\n  // Types of quotes to use for quoted identifiers\n  identTypes: QuoteType[];\n  // Types of quotes to use for variables\n  variableTypes?: VariableType[];\n  // Types of additional parenthesis types to support\n  extraParens?: ('[]' | '{}')[];\n  // Types of parameter placeholders supported with prepared statements\n  paramTypes?: ParamTypes;\n  // Line comment types to support, defaults to --\n  lineCommentTypes?: string[];\n  // True to allow for nested /* /* block comments */ */\n  nestedBlockComments?: boolean;\n  // Additional characters to support in identifiers\n  identChars?: IdentChars;\n  // Additional characters to support in named parameters\n  // Use this when parameters allow different characters from identifiers\n  // Defaults to `identChars`.\n  paramChars?: IdentChars;\n  // Additional multi-character operators to support, in addition to <=, >=, <>, !=\n  operators?: string[];\n  // Allows custom modifications on the token array.\n  // Called after the whole input string has been split into tokens.\n  // The result of this will be the output of the tokenizer.\n  postProcess?: (tokens: Token[]) => Token[];\n}\n"],"mappings":""}